var store = [{
        "title": "Information Archive",
        "excerpt":"This section provides an archive of pages that are relevant for learning as foundational knowledge that has lead to current understanding.   Table of Contents                                                                                                                                      David's Model                                                                              Data First vs. Structure First                                                      ","categories": [],
        "tags": [],
        "url": "/archives/",
        "teaser": null
      },{
        "title": "Data First vs. Structure First",
        "excerpt":"Some people find the act of categorizing and abstracting natural and rewarding, others find it frustrating and unnecessary.   The problem with information technologies is that computer programmers are likely to fall in the first category and users of such programs are likely to fall into the second one.   For example, the file system.   Files and folders are concepts that were invented by people that were managing tons of paper information and, because of that, they liked categorizing and abstracting… normal users don’t! Look at the average car, desk, room, closet… are they all perfectly ordered and structured, labeled and well categorized?   If it’s easier/faster to find something in 8 billion pages of the web than in your own 100 thousand files (including documents, emails, pictures, etc..), there’s a problem.   Another example, spreadsheets vs. databases.   Both are based on tables, rows being the items, columns being their attributes. Both allow relationships, yet spreadsheets feel suboptimal and amateurish to the average database guy and databases feel obnoxiously rigid to the average spreadsheet user. Spreadsheets (not databases!) were the reasons why people spent 10K$ on a personal computer in the early 80’s. No wonder why IBM didn’t see that coming.   Yet another example: blogs vs. CMSs.   When you blog, you don’t tell the blog where to put it. You just write, you blog. When you write a diary, you don’t pick a random page and then write an index to indicate where to locate that item. You just pick up from where you left off. Some people like to categorize their blog posts, some don’t. Some people decide what goes in their feeds, and some others allow you to have an RSS feed of a particular query.   See the pattern?   Data First strategies have higher usability efficiency (all rest being equal) than Structure First strategies.   The reasons are not so obvious:      Data First is how we learn and how languages evolve. We build rules, models, abstractions and categories in our minds after we have collected information, not before. This is why it’s easier to learn a computer language from examples than from its theory, or a natural language by just being exposed to it instead of knowing all rules and exceptions.   Data First is more incrementally reversible, complexity in the system is added more gradually and it’s more easily rolled back.   Because of the above, Data First’s Return on Investment is more immediately perceivable, thus lends itself to be more easily bootstrappable.   But then, one might ask, why is everybody so obsessed with design and order? Why is it so hard to believe that self-organization could be used outside the biological realm as a way to manage complex information systems?   One important thing can be noted:   On a local time-scale and once established, \"Structure First\" systems are more efficient.   This basically means that in any given instant and with infinite energy to establish them, structure first systems are preferable. Problem is that both bootstrapping costs and capacity to evolve over time of any given designed system are endemically underestimated, making pretty much any ‘Structure First’ project appear more appealing over ‘Data First’ ones, at least at design time.   But there is more: we all know that a complete mess is not a very good way to find stuff, so “data first” has to imply “structure later” to be able to achieve any useful capacity to manage information. Here is where things broke down in the past: not many believed that useful structures could emerge out of collected data.   But look around now: the examples of ‘data emergence’ are multiplying and we use them every day. Google’s PageRank, Amazon’s co-shopping, Citeseer’s co-citation, del.icio.us and Flickr co-tagging, Clusty clustering, these are all examples of systems that try to make structure emerge from data, instead of imposing the structure and pretend that people fill it up with data.   Some believe that the semantic web is an example of ‘structure first’ but it’s really not the case… yet, many and many people truly believe that in order to be successful a ‘Structure First’ design (well “ontology first” in this case) is the way you build interoperability.   As you might have guessed, I disagree.   I think that RDF is a good data model for graph-like structures and that complex, real life systems, tend to exhibit graph-like structures. I also believe that the value is not in the ontology used to describe the data but in the ability to globally identify (and isolate) information fragments and in the existence (or lack thereof!) of relationships between them.   Don’t get me wrong, some common vocabularies (RDF, RDF Schema and Dublin Core) go a long way in reducing the bootstrapping effort and make basic interoperability happening. At the same time, I believe people will “pick cherries” in the ontology space and when they don’t find anything satisfying they will write their own. Sometimes use and abuse will be hard to tell apart, creating a sort of Babel of small deviations that will have to be processed with a ‘Data First’ approach in mind. An immune system will have to be created, trusted silos established, peer review enforced.   Next time you spend energy writing the ontology, or the database schema, or the XML schema, or the software architecture, or the protocol, that ‘foresees’ problems that you don’t have right now think about “you ain’t gonna need it”, “do the simplest thing that can possibly work”, “keep it simple stupid”, “release early and often”, “if it ain’t broken don’t fix it” and all the various other suggestions that tell you not to trust design as the way to solve your problems.   But don’t forget to think about ways to make further structure emerge from the data, or you’ll be lost with a simple system that will fail to grow in complexity without deteriorating.  ","categories": [],
        "tags": [],
        "url": "/archives/data-first-vs-structure-first",
        "teaser": null
      },{
        "title": "David's Model",
        "excerpt":"              On This Page     Rule #1: Data First, Structure Later. Maybe.   Rule #2: Drive the content hierarchy, don’t let it happen.   Rule #3: Workspaces are for clone(), merge() and update().   Rule #4: Beware of Same Name Siblings.   Rule #5: References considered harmful.   Rule #6: Files are Files are Files.   Rule #7: ID’s are evil.           In various discussions I found that developers are somewhat at unease with the features and functionalities presented by JCR when it comes to content modeling. There is no guide and very little experience yet on how to model content in a repository and why one content model is better than the other.   While in the relational world the software industry has a lot of experience on how to model data, we are still at the early stages for the content repository space.   I would like to start filling this void by expressing my personal opinions on how content should be modeled, hoping that this could some day graduate into something more meaningful to the developers community, which is not just “my opinion” but something that is more generally applicable. So consider this my quickly evolving first stab at it.   Disclaimer: These guidelines express my personal, sometimes controversial views. I am looking forward to debate these guidelines and refine them.   Seven Simple rules   Rule #1: Data First, Structure Later. Maybe.   Explanation   I recommend not to worry about a declared data structure in an ERD sense. Initially.   Learn to love nt:unstructured (&amp; friends) in development.   I think Stefano pretty much sums this one up.   My bottom-line: Structure is expensive and in many cases it is entirely unnecessary to explicitly declare structure to the underlying storage.   There is an implicit contract about structure that your application inherently uses. Let’s say I store the modification date of a blog post in a “lastModified” property. My App will automatically know to read the modification date from that same property again, there is really no need to declare that explicitly.   Further data constraints like mandatory or type and value constraints should only be applied where required for data integrity reasons.   Example   The above example of using a “lastModified” Date property on for example “blog post” node, really does not mean that there is a need for a special nodetype. I would definitely use “nt:unstructured” for my blog post nodes at least initially. Since in my blogging application all I am going to do is to display the lastModified date anyway (possibly “order by” it) I barely care if it is a Date at all. Since I implicitly trust my blog-writing application to put a “date” there anyway, there really is no need to declare the presence of a “lastModified” date in the form a of nodetype.   Rule #2: Drive the content hierarchy, don’t let it happen.   Explanation   The content hierarchy is a very valuable asset. So don’t just let it happen, design it. If you don’t have a “good”, human-readable name for a node, that’s probably that you should reconsider. Arbitrary numbers are hardly ever a “good name”.   While it may be extremely easy to quickly put an existing relational model into a hierarchical model, one should put some thought in that process.   In my experience access control and containment are usually good drivers for the content hierarchy. Think of it as if it was your filesystem. Maybe even use files and folders to model it on your local disk.   Personally I prefer hierarchy conventions over the nodetyping system in a lot of cases initially, and introduce the typing later.   Example   I would model a simple blogging system as follows. Please note that initially I don’t even care about the respective nodetypes that I use at this point.   /content/myblog /content/myblog/posts /content/myblog/posts/what_i_learned_today /content/myblog/posts/iphone_shipping  /content/myblog/comments/iphone_shipping/i_like_it_too /content/myblog/comments/iphone_shipping/i_like_it_too/i_hate_it   I think one of the things that become apparent is that we all understand the structure of the content based on the example without any further explanations.   What may be unexpected initially is why I wouldn’t store the “comments” with the “post”, which is due to access control which I would like to be applied in a reasonably hierarchical way.   Using the above content model I can easily allow the “anonymous” user to “create” comments, but keep the anonymous user on a read-only basis for the rest of the workspace.   Rule #3: Workspaces are for clone(), merge() and update().   Explanation   If you don’t use clone(), merge() or update() methods in your application a single workspace is probably the way to go.   “Corresponding nodes” is a concept defined in the JCR spec. Essentially, it boils down to nodes that represent the same content, in different so-called workspaces.   JCR introduces the very abstract concept of Workspaces which leaves a lot of developers unclear on what to do with them. I would like to propose to put your use of workspaces to the following to test.   If you have a considerable overlap of “corresponding” nodes (essentially the nodes with the same UUID) in multiple workspaces you probably put workspaces to good use.   If there is no overlap of nodes with the same UUID you are probably abusing workspaces.   Workspaces should not be used for access control. Visibility of content for a particular group of users is not a good argument to separate things into different workspaces. JCR features “Access Control” in the content repository to provide for that.   Workspaces are the boundary for references and query.   Example   Use workspaces for things like:      v1.2 of your project vs. a v1.3 of your project   a “development”, “qa” and a “published” state of content   Do not use workspaces for things like:      user home directories   distinct content for different target audiences like public, private, local, …   mail-inboxes for different users   Rule #4: Beware of Same Name Siblings.   Explanation   While Same Name Siblings (SNS) have been introduced into the spec to allow compatibility with data structures that are designed for and expressed through XML and therefore are extremely valuable to JCR, SNS come with a substantial overhead and complexity for the repository.   Any path into the content repository that contains an SNS in one of its path segments becomes much less stable, if an SNS is removed or reordered, it has an impact on the paths of all the other SNS and their children.   For import of XML or interaction with existing XML SNS maybe necessary and useful but I have never used SNS, and never will in my “green field” data models.   Example   Use   /content/myblog/posts/what_i_learned_today /content/myblog/posts/iphone_shipping   instead of   /content/blog[1]/post[1] /content/blog[1]/post[2]   Rule #5: References considered harmful.   Explanation References imply referential integrity. I find it important to understand that references do not just add additional cost for the repository managing the referential integrity, but they also are costly from a content flexibility perspective.   Personally I make sure I only ever use references when I really cannot deal with a dangling reference and otherwise use a path, a name or a string UUID to refer to another node.   Example   Let’s assume I allow “references” from a document (a) to another document (b). If I model this relation using reference properties this means that the two documents are linked on a repository level. I cannot export/import document (a) individually, since the reference property’s target may not exist. Other operations like merge, update, restore or clone are affected as well.   So I would either model those references as “weak-references” (in JCR v1.0 his essentially boils down to string properties that contain the uuid of the target node) or simply use a path. Sometimes the path is more meaningful to begin with.   I think there are usecases where a system really can’t work if a reference is dangling, but I just can’t come up with a good “real” yet simple example from my direct experience.   Rule #6: Files are Files are Files.   Explanation   If a content model exposes something that even remotely “smells” like a file or a folder I try to use (or extend from) nt:file, nt:folder and nt:resource.   In my experience a lot of generic applications allow interaction with nt:folder and nt:files implicitly and know how to handle and display those event if they are enriched with additional meta-information. For example a direct interaction with file server implementations like CIFS or Webdav sitting on top of JCR become implicit.   I think as good rule of thumb one could use the following: If you need to store the filename and the mime-type then nt:file/nt:resource is a very good match. If you could have multiple “files” an nt:folder is a good place to store them.   If you need to add meta information for your resource, let’s say an “author” or a “description” property, extend nt:resource not the nt:file. I rarely extend nt:file and frequently extend nt:resource.   Example   Let’s assume that someone would like to upload an image to a blog entry at:   /content/myblog/posts/iphone_shipping   and maybe the initial gut reaction would be to add a binary property containing the picture.   While there certainly are good usecases to use just a binary property (let’s say the name is irrelevant and the mime-type is implicit) in this case I would recommend the following structure for my blog example.   /content/myblog/posts/iphone_shipping/attachments [nt:folder] /content/myblog/posts/iphone_shipping/attachments/front.jpg [nt:file] /content/myblog/posts/iphone_shipping/attachments/front.jpg/jcr:content [nt:resource]   Rule #7: ID’s are evil.   Explanation   In relational databases IDs are a necessary means to express relations, so people tend to use them in content models aswell. Mostly for the wrong reasons through.   If your content model is full of properties that end in “Id” you probably are not leveraging the hierarchy properly.   It is true that some nodes need a stable identification throughout their live cycle. Much fewer than you might think though. mix:referenceable provides such a mechanism built into the repository, so there really is no need to come up with an additional means of identifying a node in a stable fashion.   Keep also in mind that items can be identified by path, and as much as “symlinks” make way more sense for most users than hardlinks in a unix filesystem, a path makes a sense for most applications to refer to a target node.   More importantly, it is mix:referenceable which means that it can be applied to a node at the point in time when you actually need to reference it.   So let’s say just because you would like to be able to potentially reference a node of type “Document” does not mean that your “Document” nodetype has to extend from mix:referenceable in a static fashion since it can be added to any instance of the “Document” dynamically.   Example   use:   /content/myblog/posts/iphone_shipping/attachments/front.jpg   instead of:   [Blog] - blogId - author  [Post] - postId - blogId - title - text - date  [Attachment] - attachmentId - postId - filename + resource (nt:resource)  ","categories": [],
        "tags": [],
        "url": "/archives/davids-model",
        "teaser": null
      },{
        "title": "Quick-Start Guide",
        "excerpt":"Getting started with AEM is hard, from both business and technical perspective, here are some starting points.          On This Page     Learning AEM   Understanding AEM   Developing in AEM   Trying out AEM.Design        Learning AEM   Leaning AEM from scratch is a daunting task, as the platform is on one hand is mature and on the other hand is picking up pace of development of new features. This combined with rest of tech that needed around AEM to make thing work creates and ever ending and expanding domain for leaning.   There is an infinite ways of doing things in and with AEM, AEM.Design aims at creating reusable patterns tech that help to learn AEM and other tech that helps with your journey.   Here are some helpful resource for you to ge started.      Manifesto - light weight preparation of concepts   Manual - AEM.Design documentation   Developing User Guide - there is a lot of info and its good a s reference. This blog tries to create more targeted approach to getting started.   Data Modeling - David Nuescheler’s Model. #1 Rule must be your guiding start at all times when developing for AEM. You will find that its very easy to sway from this and you will see a lot of opportunities to break this and other rules. Be vigilant and stay alert.   Understanding AEM   You need to understand that you need to change the way you think and adapt to AEM ways of doing thing both from approach and technology perspectives.   We urge you and your team to learn about AEM together, this will allow to establish a common understanding and nomenclature for use with AEM.   AEM has been developed over many years and has a history of concepts that have been developed to solve common problems that you already experiencing but most likely articulating and conceptualising from different perspective.   What you need to know before you start with AEM.      From technology perspective its not like any other CMS platforms. Its best to start with an open mind.   You need to learn and understand these rules Data Modeling - David Nuescheler’s Model. #1 Rule must be your guiding start at all times when developing for AEM. You will find that its very easy to sway from this and you will see a lot of opportunities to break this and other rules. Be vigilant and stay alert.        Learn how content is manipulated in AEM Manipulating Content using Sling. At the core of AEM is Sling and it the technology that makes AEM Content Centric. Its responsible for content location and presentation.       Selectors - a way of passing information to URL without using query strings.   Components - base building block of all pages and other content presentation.   Working with repository   Content Packages - a way of adding/installing content into AEM using a Content Package ZIP file. You can also Uninstall Content Packages after you have installed.   Run Modes - a way of separating your configurations of AEM using content.   Learn the syntax of new templating language used for presentatio of content in AEM using HTL Scripting Engine. HTL Scripting Engine is new but very mature templating framework. Its build on top of JSTL and provides a number of helpful patterns for dealing with presentation of content.   Learn Concept of Authoring and Publishing   Learn how content is authored in AEM from example of existing projects Working in AEM. Content Authoring Experience is critical to working effectively in AEM, understanding impacts on Authoring though your work is critical to AEM development.   Learn about Dispatcher this is the most critical element of AEM architecture and it gives the sites ability to be cashed. Think of dispatcher as a static site generator but without the build process. Dispatcher caches each request content on disk first time and from then on forward servers those request from disk. Dispatcher grabs new version of content urls only after Publisher triggers an API to notify Dispatcher that particular URL has been updates. Dispatcher only gets new URL when they are requested, this saves a lot of resources.   Learn about OSGI engine of AEM services   Developing in AEM   To get started with development on AEM you will need the following:      IntelliJ - ultimate preferably so that you can do debugging or CE if you must   Install Docker Desktop or install Minikube   Get an instance of AEM using a docker container Docker Bundle   Clone and Deploy aemdesign-aem-core that contains all of the components code. To deploy project run ./deploy-local in the project directory once you have cloned it.   Clone and Deploy aemdesign-aem-support that contains all of the supporting content, front-end code and component showcase. To deploy project run ./deploy-local in the project directory once you have cloned it.   Trying out AEM.Design   The quickest way to test out AEM.Design components is to run an AEM docker container using this command:   docker run --name author \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4502:8080 \\ -p30303:58242 -d \\ aemdesign/aem:6.5.3.0-bundle-forms   This will start an Author instance that will be available on port 4502. You can read more about this at Docker AEM Bundle.   If you want to progress to checking out the code you can clone the aemdesign-parent  repo using following command:   git clone --recursive git@gitlab.com:aem.design/aemdesign-parent.git   This will clone all of the code and related projects and will allow you to contribute to AEM.Design.   If you want to leverage AEM.Design to speedup your project delivery, you can start by creating a tenant project base on aemdesign-archetype using following command:   mvn archetype:generate \\ -DarchetypeGroupId=design.aem \\ -DarchetypeArtifactId=aemdesign-archetype \\ -DarchetypeVersion=1.0.71 \\ -DgroupId=au.com.projectx.aem \\ -DgroupTitle=\"ProjectX AEM\" \\ -DartifactId=projectx \\ -DartifactTitle=\"ProjectX AEM\" \\ -DparentArtifactId=projectx-parent \\ -DparentArtifactName=\"ProjectX :: AEM :: parent\" \\ -Dpackage=projectx \\ -DpackageGroup=projectx \\ -Dversion=0.1 \\ -DcomponentGroupTitle=ProjectX \\ -DappsFolderName=projectx \\ -DcontentFolderName=projectx \\ -DconfFolderName=projectx \\ -DclientLibsFolderName=projectx \\ -DclassNamespace=au.com.projectx.aem \\ -DappsParent=aemdesign   You can read more about the available properties to tailor them to your project. Using this archetype will ensure that you have a ready to go project with Component Placeholders, Automation Tests and Showcase Site. You can read more on the importance of these artifacts in Knowledge Flow Map overview.  ","categories": [],
        "tags": [],
        "url": "/quick-start-guide/",
        "teaser": null
      },{
        "title": "Contributing",
        "excerpt":"Having trouble working with the theme? Found a typo in the documentation? Interested in adding a feature or fixing a bug? Then by all means submit an issue or pull request. If this is your first pull request, it may be helpful to read up on the GitHub Flow first.   Minimal Mistakes has been designed as a base for you to customize and fit your site’s unique needs. Please keep this in mind when requesting features and/or submitting pull requests. If it’s not something that most people will use, I probably won’t consider it. When in doubt ask.   This goes for author sidebar links and “share button” additions – I have no intention of merging in every possibly option, the essentials are there to get you started :smile:.   Pull Requests   To help out try to avoid creating pull requests on master and instead branch off of develop. It’s much easier to test, merge, and roll them into new releases this way.   Theme documentation and demo pages can be found in the /docs if submitting improvements, typo corrections, etc.  ","categories": [],
        "tags": [],
        "url": "/contributing/",
        "teaser": null
      },{
        "title": "License",
        "excerpt":"AEM.Design knowledge is released under Apache 2.0 license.   Copyright (c) 2021 AEM.Design Team   You can read about Apache 2  ","categories": [],
        "tags": [],
        "url": "/license/",
        "teaser": null
      },{
        "title": "Terms and Privacy Policy",
        "excerpt":"       On This Page     Cookies and Web Beacons           Google Analytics       Google Adsense                Cookies and Web Beacons   When you visit this site “convenience” cookies are stored on your computer when you submit a comment to help you log in faster to Disqus the next time you leave a comment.   Third-party advertisers may also place and read cookies on your browser and/or use web beacons to collect information. This site has no access or control over these cookies. You should review the respective privacy policies on any and all third-party ad servers for more information regarding their practices and how to opt-out.   If you wish to disable cookies, you may do so through your web browser options. Instructions for doing so can be found on the specific web browsers’ websites.   Google Analytics   Google Analytics is a web analytics tool I use to help understand how visitors engage with this website. It reports website trends using cookies and web beacons without identifying individual visitors. You can read Google Analytics Privacy Policy.   Google Adsense   Google Adsense, a third party affiliate marketing network, uses cookies to help make sure I get a commission when you buy a product after clicking on a link or ad banner that takes you to the site of one of their merchants. You can read Google Adsense Privacy Policy.  ","categories": [],
        "tags": [],
        "url": "/terms/",
        "teaser": null
      },{
        "title": "Component Timing",
        "excerpt":"This is a landing page for AEM.Design Timing component, it will draw a graph for duration of components that executed during AEM server side page generation.   Click here for a sample output           ","categories": [],
        "tags": [],
        "url": "/component-timing/",
        "teaser": null
      },{
        "title": "Manifesto",
        "excerpt":"This manifesto aims at capturing aspects important to understanding and learning of AEM.   Like AEM this work is in still evolving so follow our twitter of check back when you can.   Please note this is WORK IN PROGRESS you are welcome to contribute with content or comments of what you would like to see in this work.   Table of Contents                                                                                                                                      Introduction                                                                              Principles                                                                              Capabilities                                                                              Delivery                                                                              Project                                                                              Content                                                                              Components                                                                              Tenants                                                                              Deployment                                                                              Technical                                                      ","categories": [],
        "tags": [],
        "url": "/manifesto/",
        "teaser": null
      },{
        "title": "Introduction",
        "excerpt":"              On This Page     Word of Caution   Future Topics           Chapters in this document cover concepts and patterns that are aimed as introductory topics for the AEM Platform. These chapters is complementary to the overall Digital Strategy maintained by the Digital Retail Business. This document is a living document is aimed at being used as a tool to socialise the practice of AEM at any company.   Word of Caution   Majority of terms that are used in AEM such as Pages, Sites, Assets are there as a historic naming convention that is used to make sense for comparable reasons to new users of the CMS, with prior experience in other CMS platforms. Fundamentally in AEM everything is content and a mind shift need to take place when migrating to remove the restrictions for content authoring and reuse. This is applies to all users of AEM, from developers to authors.   Future Topics      Language Masters   Translation Context and Rules   Projects - Calendar View   Inbox   Comparison Diff   Forms   Content Fragments   Experience Fragments   Templates and Template Editor   Apps   Social   Screens  ","categories": [],
        "tags": [],
        "url": "/manifesto/introduction/",
        "teaser": null
      },{
        "title": "Platform Principles",
        "excerpt":"              On This Page     Contentricity   Authorability   Experiences   Digital Channel Agility           Continuous Delivery and Continuous Integration       Test Driven Development       Behaviour Driven Development/Testing           Collaborative Development   Content is Forever           Contentricity   Davids Model - 7 Rules is reference to fundamental approach behind AEM(CQ) architecture. All of the technical frameworks that make up the platform are all targeted to support Content Centric approach of the CMS. This is different to other CMS platforms and something that must be learned and iterated to all involved.   Major benefit of Content Centric approach is that Governance of the CMS and its development is managed by Business. This is done by managing the experiences of the platform. The platform is a facilitator and development effort is used to enrich content presentation and not extending the platform capabilities.   Authorability   All content in CMS should be authorable. Fundamental guide to business analysts working on new business features that when it comes to CMS it’s important to build content perspective of the feature being developed. This enables an insight and a clear direction for the developers to ensure that components they develop can be configured by Authors. At the same time developers are ensuring that all the development work that they create enable feature customisations without their immediate involvement. This enables developers to building tools for the business authors to build the site. In other words develops build small puzzle pieces in a form of loosely coupled pluggable components so that an authors can mix and match components to create unlimited combinations of content presentations.   Experiences   While projects concentrate on developing new feature components it’s important to evaluate and plan other authoring experiences that are available in AEM platform.   Primary experiences that must be considered at all times (1) authoring experience, (2) channel experience and (3) delivery experience.           Author Experience - Business Authoring, Outports, Vendors etc            Channel Experience - Mobile, Digital Publishing, Web, Apps, API, other            Delivery Experience - Dev Cycle, DevOps       Digital Channel Agility   Digital Agility is a measure of duration for delivering of change to channels. There are many ways of achieving this and every one does what is necessary to meet their needs. When implementing partners to encourage agility, measuring the cost efficiency of process can help to eliminate bottleneck and streamline the process. Concentrating on implementing patterns that provide transparency in delivery of outcomes and measurement/testing of outcomes in relation to initial agenda will be of most benefit.   Continuous Delivery and Continuous Integration   This is not a new concept and means “assembly line” like process utilising autonomous build, test and deployment cycles which deliver software directly to production with minimum input from users.   Test Driven Development   This is not a new concept and in relation to CMS means component level functional testing written by developer that enable measurement/testing of outputs by the development team. This also contributes to larger Testing Framework for the platform which is further used for Regression testing.   Practical Functional Testing that is reusable and can be managed by Business and can be used for more than one purpose.   Behaviour Driven Development/Testing   This is not a new concept and in relation to CMS means component level definition of acceptance criteria and testing cases in a uniform manner, as it becomes the base for automated testing.   Collaborative Development   Agile is a principal that applies to Software Development, it does not mean its a free for all. Free for all being, no documentation and no proper ceremony, if anything it means more of it and more often. Agile is collaborative, its a dialog within the business that involves everyone who is helping on the project. Its a mechanism of short bursts of efforts with quick feedback loop that enables assessment and in turn enables agility. Agile does not mean that there should be no planning and no documentation, it just means that planning and documentation should be done incrementally and without wasting effort. This means that if documentation is done as a prelude to moving to the next stage   Content is Forever   Consider that when creating content structures you are creating them once and forever   For example if you create a bookmark to an article, you expect that article to remain there for a long time. Changing content URL content creates a challenge, leaving content in the same place is easier and more sustainable.   ","categories": [],
        "tags": [],
        "url": "/manifesto/principles/",
        "teaser": null
      },{
        "title": "Capabilities",
        "excerpt":"              On This Page     Tags   Digital Asset Management           Asset Metadata       Asset Renditions       Asset Share           Experience Manager Dashboard           Projects Dashboard       Projects - Experiences           Authoring Experience           Page Editor                   AEM stands for Experience, its the primary differentiating factor that separate it from other products.   Please note that images depicted in this section are from AEM6.   Tags   Tags must be used to classify content within CMS. Tags structured in namespaces provide a flexible and extendable layer when designing metadata for assets and content. The OOB components associated with Tags provide simple and effective authoring experience and should be used to drive Authoring Experience where Lists and Arbitrary Structures are required on dialogs. Management of Tags in AEM allows ability for the Business users to extend their content experience without needing to update code.      Digital Asset Management   The term Assets in AEM also know as DAM in short refers to the Digital Asset Management capability. Its primary use is to share and distribute assets within an organisation. As DAM is integrated into AEM platform the images from DAM can seamlessly used in the Authoring experience.      Asset Metadata   Asset Metadata is additional data for the image, it enriches user experience as the information for the image is stored with the image and can be reused by component in places where its appropriate. For example a metadata description field if entered would appear in an Image component to convey additional information to the viewer.      Asset Renditions   Asset renditions allow you to generate using a workflow or manually upload renditions for an asset.      Asset Share   Asset Share Commons is an alternative way of presenting DAM library to consumers. It is best used when delivering DAM access to 3rd Party and External customers.      Experience Manager Dashboard   Project dashboard should be used to tailor the presentation for authors. Each Outport should have a Tile (Project) created that will contain relevant information and links to relevant areas that they frequently use.      Projects Dashboard   Project dashboard should be used to tailor the presentation for authors. Each Outport should have a Tile (Project) created that will contain relevant information.      Projects - Experiences   Links to relevant areas for Content Authors while they are working on a campaign project. A calendar view allows author to see when projects are due.      Authoring Experience   Page Editor   Desktop and Mobile authoring interface for Pages.     ","categories": [],
        "tags": [],
        "url": "/manifesto/capabilities/",
        "teaser": null
      },{
        "title": "Delivery Guide",
        "excerpt":"              On This Page     Components           Experience       Presentation                   Concept: Component to Design/Style Relationship           Concept: Details and List                           Component Categories   Sling Selectors   Content Modelling           Content Segmentation       Segmentation Reference                   Pages           Assets           Tags                           Component Templating           HTL Templates                   Components   Components are the basic building blocks in AEM. When designing components two aspects must be considered, experience and presentation. Experience will help to understand out how the component is used by authors, how it is linked to content within CMS and how it will be used by the end user. Presentation will help to understand the presentation of the component in different content contexts (on its own, in admin view, in a list), its integration into front end frameworks and its indirect interaction with other components (on same page, across pages, across sessions).   It is important to keep the component’s (authoring) experience simple and separate from the presentation:           Mixing presentation behaviour with authoring experience will complicate the component’s design. For example, the frameworks used for presentation may introduce incompatibilities with the authoring environment.            Mixing presentation behaviour with authoring experience would introduce additional ways of authoring for the content authors.            The presentation will (and should) change more rapidly than the authoring experience.       Experience   Component presentation is divided into two primary dialogs, Content Dialog and Design Dialog. Content Dialog is also known as “Dialog” and refers to the interface an Author uses to input content for component. When an Author uses the Content Dialog to input content they are providing actual Content, Layout and Style values for that instance of the component on a page. Design Dialog on the other hand is used to configure the Default Content for the component instance within a Page Template. This allows for creating default Style configuration and possible content Placeholders for component Presentation. This enables a default Component Layout that matches a Style Guide and that does not require initial Style input per each component placed on pages by the authors.   Presentation   Component presentation should be broken down to two main areas: Variants and Badges. Variants is an output of components content on a Page, Badges is an output of the components content in a List Component. This means that if component is not going to be used in a List component it should not have any Badges. All components will have a Default Variant that will be used by default that component is placed on a page.   Variants for a component display content, so each Variant should have different content output, Title for the Variant should also be representative of the Content that the Variant uses, this makes it easier to teach Authors. Each variant will have a Default Style and other styles that will be created over time.      This breakdown enables ability to update the Look And Feel of component without having to update the component code.   Concept: Component to Design/Style Relationship   This concept allows few components that can be authored in unlimited layouts to create the end experience.      Concept: Details and List   Details is about providing a place holder for a placeholder for structure content   List is about proving a placeholder for display of content in a list      Component Categories   It’s important that each component is understood from its CMS perspective, this planning for a component should start from inception of component, before its development has started. Keeping component isolated into their CMS functional groups is important as its keeps the component library organised and it fundamentally defines the component expected behaviour.   Here are initial list of CMS Functional Groups for components:      Content - primary components used to store authored content, content from these components is used by other components for display   Layout - provide layout ability, grouping and structuring of content, contain layout and style related content   List - find content and show data in listing, contain layout and style related content   Details - used to create and display custom metadata for different page types   Widgets - used to provide client-side functionality, integrating 3rd party services   Commerce - used for eComponents, shopping carts, checkouts, product listing etc   Common - used for shared components that are available to authors   Forms - used to contain all the components that are used in forms   Template - used to store all the available Template components that contain HTML page structures   Media - Assets related component, galleries, asset lists, videos etc   Workflow - steps that appear in workflow editor   NOTE: Adding new items to this list should be communicated and designed thoroughly, as these groups reflect and relate to CMS functions   Sling Selectors   Apache Sling is at the core of AEM, it enables all the authoring and content serving functions. Here is the high level overview of the framework:      REST based web framework   Content-driven, using a JCR content repository   Powered by OSGi   Scripting inside, multiple languages (JSP, server-side javascript, Scala, etc.)   Apache Open Source project   Sling selectors should be used to pass parameters specific to rendering and not content filtering. (reference)   If selectors are used for content filtering, then you are allowing unlimited number of URLs for a particular piece of content. This opens up opportunity for DDOS attacks in two ways:      Attackers can flooding the Publishers with content requests using bogus selector values, making the publishers unable to serve legitimate requests.   Attackers can overload the Dispatchers’ filesystem with cached files generated from bogus selector requests.   Content Modelling   At best content authored should be located either below current page being authored or be on the page. Situation where you require content located outside current page and its descendants should be kept to a minimum, as OOB functionality only detect relationships between Tags and Assets. This plays a primary role when activating and deactivating content pages, to detect indirect relationships additions code will need to be written.   Content Segmentation   Following is a list of types of path segmentation’s that should be applied when creating content architectures in a CMS.                  Pattern       Description       Examples                       By Site       Content should be segregated by sites first, this allows simple management and can be easily secured       /content/site/..  /content/site-showcase/..  /content/dam/site/..  /content/projects/site/..                 By Language       Content should be segregated into Language Locale subfolder so that it can be translated into appropriate language       /content/site/en/..  /content/site/ru/..                 By Date Range       Any content that is generated over time and has a long life should be segregated into date range Hierarchy YYYY/MM/DD. Day is optional and should be omitted if no more than 200 assets are added per day, if more than 200 items required then additional segmentation should be used, either HH or functional grouping, which segments content in an even manner       /content/site/en/news/{year}/{month}/title  /content/site/en/news/{yyyy}/{mm}/{dd}/title                 By Functional Group       Content at any level should be grouped into functional groups that make sense to the Authors when searching content manually. eg. Banners, Advertising, Posters, Portraits       /content/dam/site/assets/accounts/..  /content/dam/site/assets/designers/..                 By Content Collection       Where possible when Assets belong to a group/set/collection they should be segregated into Collections, for example uploading a set of images that will be used in a Photo Gallery they should be placed into a folder describing the Collection       /content/dam/site/galleries/collection/..  /content/dam/site/videos/collection/..                 Content Metadata       Content must have at least a legible Title, Description and Tags assigned when being added       /content/site/en/specials {title: Specials }  /content/site/en/corporate {title: Corporate}                 Content Tagging       Content must be tagged to describe its nature, this helps in ability for Authors to find this content. One must not rely on content structure to find content, free text search should be considered first       /content/site/en/specials {tag: Products}  /content/site/en/corporate {tag: Corporate}           Segmentation Reference   Pages   Sample hierarchy for Page tree      Content Root            Site Root                    Language                            Section                                    Sub-Section                                            Content                                                    Sub Content                                                            …n                                                                                                                                                                                                                                   Assets   Sample hierarchy for Assets tree      Content Root            Site Root                    Language                            Section                                    Category                                            Asset                                                                                                                           Tags   Sample hierarchy for Tags tree      Content            Tags Root                    Namespace                            Category                                    Group                                            Tag                                                                                                                           Component Templating   These are several methods that can be employed to create templates for components. The most basic method is to use simple HTML fragments that can be kept in separate JSP files and included using logic that relies on content input into the component. This practice allows for simple authoring and maintenance mechanism whereby Frontend Designers can participate in updates of component HTML structure. This collaborative activities create agility and does not require continued developer effort.   HTL Templates   In AEM 6 a new templating engine called Sightly/HTL has been introduced that aligns better with the design practices and development efforts. It is based on JSTL and has been tailored specifically around component templating and content structures. It provides a familiar HTML syntax with Templating variable conventions similar to JSTL and other Javascript frameworks.  ","categories": [],
        "tags": [],
        "url": "/manifesto/delivery/",
        "teaser": null
      },{
        "title": "Project Guide",
        "excerpt":"              On This Page     Project Documentation   Component Specification   Project Archetype   Project Concept to Creation           Knowledge Flow Map                   Co-Learning loop 1           Co-Learning loop 2           Co-Learning loop 3           Co-Learning loop 4                       Evolution of Artifacts           Development Flow   Content Migration           Project Documentation   Important principle on project is to understand why you are creating content, primary driver for creating must be for reuse by someone else on the project. It’s important that documentation is seen as a journey not a deliverable. Everyone should be using documentation as a way of sharing knowledge with another person on the project. The documentation that is written without an audience on a project is wasted.   This is a sample TOC that can be used as a starting point for projects, you may not require all of the sections but at some point in your project question and need for information will arise and will require a placeholder to communication knowledge to the team.      Project Library            Management Design                    Knowledge Management                            Project FAQ - Getting started with documentation               Keyword Index - auto generated from page Tags               Comments               Recent Activity                                   Deliverables - list of all deliverables           Roles - team, support, ops           Guidelines                            Task Management - Jira usage, stories, tests, bugs               Knowledge Management - Confluence usage, specs, review               Page Specification - Template Description               Component Specification - Template Description                                    User Story                   Acceptance Criteria                   Behaviour Driven Testing                                                                   Meeting Notes                            Meetings               Retrospectives               Discovery Sessions                                   Reporting                            Status Reports               Reporting Documents - list of pages tagged for reporting               Automated Test Result Reports                                   Steakholder Registry                       Experience Design                    Unique Experiences                            Unique Experience Specification                                   Component Catalog                            Component Group                                    Component Specification                                                                   Content Hierarchy           Dialogs - Shared Dialogs           Frameworks - Design Frameworks listing           Authoring Helpers                            Scaffolding - Forms that will be used by Authors               Blueprints - Site templates               Dashboards - Updates to Dashboards               Reports               Authoring UI Updates                                   Styles - General Styles applied to all components           Tag Namespaces - Tagging for Content           Dictionaries - Labels for component           Templates - Available Templates           Workflows - Workflows to be built           Error Pages - Error pages that will appear           Translations - Translations to be used           Selectors - Selectors available           Services - Services available           Accessibility           Browsers and Devices                       Platform Design                    Architecture                            Solution Description - provides a overview of whole solution               Logical Architecture               Physical Architecture               Service Architecture - service, data, interfaces                                    Service Catalog                                               Delivery Architecture - ci/cd cycles               Content Architecture               Information Architecture               Testing Architecture               Development Architecture                                    Developer Setup                                               Integration Architecture               Quality Architecture               Security Architecture               Analytics Architecture               Business Architecture                                               Operations Design                    Content Migration           Integrations Services           Service Licensing           Environment Config - service addresses           Training Manual           Vendor List           Error Register           Environments           Groups and Permissions           Workflows                           This is not a prescriptive TOC and things should be added and removed as required.   Component Specification   Content specification is the single document which is used to describe the component to be build and all of the relevant information needed. From this document a developer can determine if the component can be built. The whole team spends their effort to ensure this document is in an acceptable state so that developers can carry out their work using this document as a guide.   The document covers these main areas                  Management       Authoring       Design                       User Stories Component Summary Component Hierarchy Acceptance Criteria Test Cases       Authoring Dialogs - Design - Content Related - Tags - Dialogs       Variants Badges Theme                 Input From BA, PO, TS, DEV, DES       Input From BA, DEV       Input From BA, DEV, DES           Project Archetype   Recommended practice to build AEM projects is to use Apache Maven tool. To make it easier to create new project AEM.Design Archetype can be used and it will create you project that is ready to be used by authors.   Running following command will generate a sample project  mvn archetype:generate \\   -DarchetypeGroupId=design.aem \\   -DarchetypeArtifactId=aemdesign-archetype \\   -DarchetypeVersion=1.0.52 \\   -DgroupId=design.aem.projectx \\   -DgroupTitle=\"ProjectX\" \\   -DartifactId=projectx \\   -DartifactTitle=\"ProjectX\" \\   -DparentArtifactId=projectx-parent \\   -DparentArtifactName=\"ProjectX :: AEM :: parent\" \\   -Dpackage=projectx \\   -DpackageGroup=projectx \\   -Dversion=0.1 \\   -DcomponentGroupTitle=MMAL \\   -DappsFolderName=projectx \\   -DcontentFolderName=projectx \\   -DconfFolderName=projectx \\   -DclientLibsFolderName=projectx \\   -DclassNamespace=design.aem.projectxm \\   -DappsParent=aemdesign    AEM.Design Archetype has the following modules and contents                  Level 1       Level 2       Description                       parent               parent for new projects                         {tenant}-aem-author       contains all of the update to OOTB AEM Functionality                         {tenant}-aem-common       contains all of the components for project                         {tenant}-aem-config       contains all of the config content for repo                         {tenant}-aem-content       initial seed content to be added to clean AEM instance, used only in development                         {tenant}-aem-deploy       project for deploying project as one package                         {tenant}-aem-compose       standard project for developing DLS and customer facing components                         {tenant}-aem-services       all of the service code, bundle deo, helpers etc, anything that needs unit testing                         {tenant}-aem-showcase       content used for demonstrating components during sprints                         {tenant}-aem-training       content used for teaching Authors how to use components and build pages, see example                         {tenant}-testing       automated functional testing scripts           At the high level an AEM project consist of Bundle and Content packages.  Bundle package contains all the code that is required for the Application, it should contain any services, servlets and helper functions. Content package contains the configuration content, all the component configuration and code as well as Designs content. Its a best practice to divide projects into multiple project as soon as first release occurs. This help with maintenance, bug fixing and dependency management. It also creates a practice of ensuring that component and code does not become tightly coupled.   Project Concept to Creation   Knowledge Flow Map   The diagram below illustrates how a business concept flows through the necessary parties to get to the desired end state, which is a functional component that can be tested (and passed) on a showcase site, so that the business owner can utilize it in the organization’s production environment.      The idea for Knowledge Management is to leverage co-learning patterns within the organisation. Doing this allows all participants to learn gradually and at the same time reflecting their learning outcomes into artifacts used as inputs to though the process.   Artifacts are sources of information that represent knowledge, and keeping these artifacts current is foundational for organisations. Within organisations, artifacts are used for training, education and inspiration, not having the latest information at hand creates lead to misinformed actions. Adopting a systemic process approach ensures that artifacts contain most relevant up to date information.   Following is a typical best case scenario flow from idea to implementation. This flow is formed around Co-Learn loops that enable learning feedback and shared artifact updates. This process of learning and persisting knowledge as information in shared artifacts enables systemic knowledge sharing, artifact update and feedback loops.   Co-Learning loop 1   A business owner establishes a new idea and consults a Training Suite to establish if that idea can be delivered using existing functionality. When a business owner is unable to determine if they have the capability for a specific function, they engage a Business Analyst.   Co-Learning loop 2   Business Analyst evaluates Training Suite and bases on existing knowledge establishes if the material needs to be updated to provide insight on how business owners idea can be achieved using existing functionality. Updating the Training Suite with relevant information allows this knowledge to be captured and enables a business owner to use that as a reference for their idea.   Co-Learning loop 3   When business analyst determines that based on their best experience and information available that additional feature may be required they engage a designer. The designer uses existing Concept Suite to determine if existing Design Language System already caters for a particular capability. Updates the Design Language System with relevant  Unique Experiences that match requirements and provide Business Analyst with additional information to update Training Suite. When a Concept Suite does not have the required features that deliver requirements, the designer updates the Concept Suite with appropriate changes and then composes them into Compose Suite. This process ensures that design concept and its Language is persisted for Author (Business Owner) usage. Updating compose suite allows the author to leverage updated design elements for their new idea.   Co-Learning loop 4   When a Compose suite does not have structural components that needed to support design, a developer is engaged in providing insight on possibilities. A developer uses their knowledge and provides insight if existing functionality could meet the capability needed. When existing functionality does not exist a developer creates a needed component, creates component showcase pages and develops initial functional tests that prove that component works as per specified requirements. After these artifacts are created, the feature is deployed to production and the upstream artifacts are updated to match.   As you can see in all these co-learning cycles a process of finding knowledge, actioning it and providing feedback is facilitated by shared artifacts.   Following is a list of artifacts and their purpose:      Training Suite - this artifact is primary goto by the authoring community for learning on capabilities available. This artifact follows a typical training system capability, but its implemented in AEM, and only this allows it to be maintained by the community of authors as they learn the system capabilities. Ensuring that authors can maintain their own help manual is a crucial approach to education and ownership, as it ensures that the site is built from the same components that authors use on other sites. See the following link for a good example of how to do it well https://www.sfu.ca/cms.html.   Concept Suite - is an artifact used by designers to articulate an early version of the design system and present potential possibilities. Typically it starts off with having a design focus and then transitions into an actual Design Language System that is used to align overall experience for end-users and authors.   Compose Suite -  is an artifact that helps to translate the design vision into a style and behaviour pattern based on AEM component models and represent design language into content that authors will use to author and create experiences in AEM. Its is the artifacts that compose the design and component structure with design language.   Component Suite - is the main component code artifact, it is used to represent component structure and models that are used by designers to create visual experiences, as well as an additional component that support author experiences.   Showcase Suite - is a demonstration of component functionality and design language. It’s used to demonstrate atomic functionality of components as well as their usage in Unique Experience, and it used to represent a Design Language System to authors. Most importantly, this artifact is responsible for providing the structure for automation testing, which is the primary mechanism for ensuring that components are operating as required.   Testing Suite - is the automation suite that contains all of the automation tests that prove component operation as well as provides a mechanism for regression testing.   These artifacts form kickstart of the AEM.Design framework that comes with over 90 components and matching design system blueprint, as well as a set of showcase content and tests and provides a demonstration of components. This ensures that the delivery team does not start from scratch and have a solid end-to-end delivery starting point ready for use.   Evolution of Artifacts   All artifacts on a project evolve over time and give input in other artifacts.      Idea behind each artifact is to provide input into other artifacts and be useful for more than one purpose.   Development Flow   This is a high level flow for development cycles              Build Deploy Test: Developers work on local environment which is a replicate of target production, using same codebase as build server and performs all Build, Deploy and Test functions on local instances of AEM using docker containers.            Dependency Resolution: Local Developers build environment uses centralised Maven repository to resolve dependencies in Build cycle            Commit: Developers code is commit code to Code repository            Tracing: Code is linked to Stories by Story ID added to each commit            Trigger: Each commit triggers a Build Test Deploy cycle on the Automation server            Build Tracking: Build tracking is reported into Jira            Build Artifact Storage: Build Artifacts are stored in Jira to be used in Depoy cycles            Build Test: Automated testing of Code is performed after Build an before Deploy cycle            Build Analysts: Automated Code Quality review is performed after Build an before Deploy cycle            Deploy: Deploy cycle is triggered automatically and manually to a defined environment       Content Migration   When migrating from legacy CMS plaforms you will be challanged to migrate content into AEM. To migrate content into AEM you can follow either manual or automated process.   Following diagram demonstartes how an automated process should be developed. This methiod should be executed in parallel with the project that is developing component catalog.      Typicaly content migration start right at the start of the project to allow enough time to understand source data and transform it into AEM content. Where possible migrate content data into Content Fragments and use workflows to create pages using a Content Fragment Page Generation workflow this will allow you to separate your content from pages. This will also enable you to change your page layout later once you have developed all of your components, as you can re-create all of your pages.  ","categories": [],
        "tags": [],
        "url": "/manifesto/project/",
        "teaser": null
      },{
        "title": "Content Modeling",
        "excerpt":"              On This Page     Content Types           Content Experiences           Primary Content           Pages                   How to start authoring content early?                       Assets       Tags       Screens       Forms           Secondary Content           User       Cloud Services           Metadata Experience           Tags       Page       Asset       Components       Designs                   Organisations that dedicate resources on planning and designing Content Management Practices within the core business at some point implement a Content Management System that support the Business Processes of managing content. So it is important to keep in mind that Business Process which is part of Business Architecture comes first and foremost, their implementation in a computer system such as a CMS comes second.   Please consider that information in this document is based on capabilities that are present in the AEM platform. This is done for a reason to simplify the understanding of the concepts, as each Capability and Functions with the Platform can be explored to derive exact business process that it’s meant to support. During the process of exploration the business practitioners are able to build an understanding of Context of all features and how the apply to their business.   This document covers concepts in AEM that relate to Content Modeling and Information Management. AEM is Content Driven, which means that all activities within AEM revolve around content in its repository. This means that Content Modeling has to be a first and foremost activity of any Feature/Capability planning, as it will enable understanding of the content at the lowest level where it exist, and then enables planning of other higher level features that streamline and guide workflow for that content.   Content Types   To be able to effectively plan content needs for a CMS it’s important to segregate content into its high level Primary and Secondary content types. These content types should be used to describe business requirements and functions that needed by customers. Doing this from beginning enables a more specific context for Business and Technical analysis, as you are able understand impact on the content and derive any required updates to the Authoring experiences that link to those content types.   Primary content types are exposed to Authors and they are managed either directly or with help of additional experiences:      Pages - a container for Authored content, NOTE: this is different from ALL other traditional CMS platforms as pages are actually hierarchical and do not have fixed structure   Assets - assets and metadata including tags that is used in pages and products   Tags - metadata tags used to enrich content   PIM - products catalog   Primary content types are aimed at being Authored once into AEM and reused for multiple purposes. Reuse can be in a form of linking content types together such as adding a Tag to an Asset, or displaying an Asset on a Web Page. That ability of content Reuse comes from AEM Platform Components, that are added to enable different required perspectives.   Secondary content types that also equally important but vary in exposure Authors:      User - metadata for a user, synchronisable with external systems   Designs - UX static content and Template Component configurations   Cloud Configuration - cloud services configurations   Workflows - workflow designer   These content types are aimed at managed by specific group of Authors that have a deeper knowledge into the content and the integration nature of these types.   Content Experiences   Each of the content types in AEM has a predefined experiences, these experiences are represented in Capabilities and Functions of the platform. Its important to understand and leverage existing capabilities as much as possible.      These capabilities and function support a wide range of functions and customisations, additional customisation can be applied as a last resort.      Pages            Multi-Site Manager (MSM)       Social       Apps       Experience Fragments           Assets            Assets - Digital Asset Management (DAM)       Content Fragments - Reusable asset content           Tags            Tag Management           Commerce            Product Information Management (PIM)           Screens            Screens Management           Forms            Forms Management           AEM as a repository can be used to store any form of Content Type. Planning for these Content Types outside of AEM is critical for that contents proper usage and lifetime. It’s important that content types are thought though from business usage and function perspective before touching AEM. Translation of Content Types into AEM will enable proper implementation and allow understanding of features and components of AEM platform that will support that Content Type.   Primary Content   This section covers the primary content which is stored in AEM repository.   Pages   AEM Sites provides all the necessary tools to content authors to create “Pages” that are targeted to be consumed by the end-users through a web browser. Fundamentally the act of authoring simply creates content structures that translate into visual designs developed by developers. Majority of the time a WYSIWYG approach is used to facilitate an inplace authoring workflow that enables a more realistic representation of target state to the Authors.      How to start authoring content early?   Content authoring for AEM can start early, and you can start doing this in a document even outside of AEM, then once templates are ready, you can move this content into pages. Better approach is to leverage Content Fragments, which would allow creating content in AEM and then add them into pages for presentation. This process is great for articles, news and general pages that do not have a high degree of metadata that you might not have explored yet.   To save rework, you want to start content authoring after you have discussed Unique Experiences and have understood their content requirements.   Assets   Digital Asset Management refers largely at a practice of managing Assets. As a whole it’s a combination of management practices and metadata content that is associated with an Asset. In AEM Images and Videos are the primary Assets in addition to other      Tags   Tags are a quick and easy method of classifying content within a website. They can be thought of as keywords or labels (metadata) that allow content to be more quickly found as the result of a search. OOTB in AEM tags can be added to Pages, Assets, User Generated content and in addition to this they feature in OOTB components to allow search and filtering of content for presentation.   Tags must be used to classify content within CMS. Tags structured in namespaces provide a flexible and extendable layer when designing metadata for assets and content. The OOB components associated with Tags provide simple and effective authoring experience and should be used to drive Authoring Experience where Lists and Arbitrary Structures are required on dialogs. Management of Tags in AEM allows ability for the Business users to extend their content experience without needing to update code.      Tags can be thought of a structured classification hierarchies that can be added to content metadata. For example if a tag for a Country Location is added to a group of Assets/Pages then a Authors can easily locate All Assets/Pages that belong to that particular Location when building Galleries or when creating list of Pages. Tags can be used by authors without explicit design, but it’s recommended to perform an explicit Planning and Strategy activity to understand the long term growth of tags and their use across the whole Content Model.   Screens   Screens allow you to deploy content to your digital signage location in physical spaces, leveraging all of the content in AEM.      Forms   Forms allow you to use powerful form authoring experience to create forms that meet not only simple but also complex requirements.      Secondary Content   This section covers Secondary content that is stored in the repository, secondary content types are not not limited to this content.   User   User profiles are one of the components that enable OOTB personalisation for End-Users. Ability to synchronize users from external sources enables Personalisation components to adjust Targeting and Pages content as required. User metadata can be stored to enable personalized output of content to end users.      Cloud Services   Cloud services is configuration content that is created and update by the admin authors to enable integration with cloud services. Cloud Services configurations enable interaction with services without      Metadata Experience   Structured metadata management with tags enables usage of Tags in all parts of Authoring experience. When tags are created they can be used to tag all Assets and can be used to search for those Assets and Pages when required.   Tags   Tag management and authoring interface support multi-lingual translation and can be further extended to support additional metadata as needed. An example extension data point that can be added is creating Reference fields for Tags to enable specifying relevant Reference content that describes or details this Tag, an example would be linking an Airport Code tag to an Airport Information Page that has additional information for any component that requires more information about Airport. In this scenario new Attribute is a generic in nature and can be used for all tags as needed.      Page   Each page has several metadata attributes that support OOTB functions. Majority of metadata is optional and is used only when needed. Page metadata can be extended to support additional configuration and its recommended to inherit OOTB page management tools to ensure new functions become available after upgrades.      Asset   Assets have extensive metadata configuration options, majority of the image associate metadata can be derived from images if its provided initially part of the image Metadata. Asset processing tools would scan the image for this data and automatically add it to the Asset. Metadata profiles management tool for assets can be used to configure the Authoring interface and metadata requirements for each different Asset type.      Components   Primary input of content into AEM is done through Component Dialogs. These dialogs are configurable by developers and can be extended to provide a very rich authoring functionality. Several OOTB functions exist to enable a more simplified interaction with these dialogs. Dialogs exist in two distinctly unique modes Instance and Design. Component Instance dialog allows entry of content into the component and storing it in a Page. Component Design dialog allows storing of content initial values in the Design of a site specified part for the Page or Inherited from parent Page.      Designs   Designs provide an ability to segregate Designs from Content. Component Design content is persisted into Design content structure for each site. Site Design folder is created initially and contains all of the Static Content that is used to present a site to End-User. In addition to this Site Design contains configuration of the Authoring interface. Such as availability of Component on Templates and Component default values.   ","categories": [],
        "tags": [],
        "url": "/manifesto/content/",
        "teaser": null
      },{
        "title": "Component Modeling",
        "excerpt":"              On This Page     Dialogs           Page Properties       Design Dialogs           Supporting Experiences           Translations                   Language Copies           Create Translation           Translation Projects           Custom or Legacy                           Human and Machine               Human Translation                                   Side-By-Side                                                                               Content Best Practices                   Planning and designing your functionality around Authoring component will ensure that you are not stuck in the tech debt remediation spiral that would lead to replatforming. Chances are you are replatfrom from another technical platform and change of perspective need to happen to ensure you can leverage AEM capabilities.   In AEM components should be understood from followgin perspectives:      Authored Content - content that is input into component using component Dialog, default content added for a component in a template to enable default state as component is placed on a page, and component static values that ensure component operation without Authors input.   Component Experience - how components content is used to create desired experience on pages and how component content is used in other components   Component Data - how component data is contributing to overal data footprint of CMS, this follows Rule #1: Data First, Structure Later. Maybe.   Supporting Experiences   Dialogs   Primary method of input of content into components is by interacting with component dialogs. Component dialogs are designed to prompt user for content.   Page Properties      Design Dialogs   For component to show in the Side Kick on a particular template they are first required to be added to the design of the template. This is done through design mode and required components are selected to be available to authors. Special Authoring privileges can be assigned to prevent unauthorised modification of Designs.   Design dialogs allow you to specify default values for components when they are dropped on a page. This helps to provide default options that help authors.      Supporting Experiences   Number of component supporting experiences provide patterns that are key to leveraging AEM capabilities and makeing authoring experience content driven.   Translations   AEM supports both Manual and Automated translation of content. For checking and initiating translation a Language Copy function is used with a workflow if automation is required.   Language Copies   Language copies allow copying a particular version of a page from one Language into Another and provide assistance of starting a workflow for translation. As well as provide visual list of existing copies of selected page in different languages.      Create Translation   When creating a translation of a page a workflow can be triggered to either notify another person to conduct a Manual translation or have an external Automated script to perform initial translation.      Translation Projects   New functionality in AEM enables better status reporting on translation progress for all pages. A translation project is created to which page all required translations are assigned, progress of all workflows per pages is reflected on dashboard.      Custom or Legacy   Human and Machine   AEM supports human and machine translation workflows. To automate translation workflows, you integrate translation service providers with AEM and create projects for translating content into multiple languages. These project provide you with a dashboard that allow you to keep track of the progress of translation.           Human translation: Content is sent to your translation provider and translated by professional translators. When complete, the translated content is returned and imported into AEM. When your translation provider is integrated with AEM, content is automatically sent between AEM and the translation provider.            Machine translation: The machine translation service immediately translates your content.       Human Translation   Side-By-Side   When AEM is exposed to Translation providers for Human Translation it Side-By-Side view of pages enables much better context sensitive translation, which increases quality of translation.      Content Best Practices   References      MSM Best Practices   Translation Best Practices   ","categories": [],
        "tags": [],
        "url": "/manifesto/components/",
        "teaser": null
      },{
        "title": "Tenant Content",
        "excerpt":"              On This Page     Sites   Languages   Blueprints           Blueprints Language Requirement           Design Importer           It’s important when designing AEM implementation to plan and design all content and development to be tenant focused. Tenant focus in AEM allow understanding all of the needs to segregate and isolate content and experiences for a specific tenant. This means that from the start your content will be partitioned and enable future abilities to extend authoring experiences. Not doing this from the start will limit the opportunities for the platform to provide best experience.   Sites   Sites is the primary containers of content, they allow creation of content structures so that they can be present to End-users and reused in other pages. All content created under sites is targeted to be consumed by end-user. Sites enable ability to create replicate content as reusable structure and facilitate Multi-lingual content structures that are managed through translation services or manual language translations.      Languages   AEM is a Multi-Language aware CMS and has numerous tools that support Localisation of Language content for Sites. OOTB these tools are dependent on Site content to have particular structure for proper operation and as a best practice principles. Primary tools that are dependant on Locale are Blueprints and Language-Copy functions. Guiding principle of creating sites is that Root Level of the site has siblings of all the available Languages for the content of that site. Content is authored in one of the languages and Language-Copy tool is used to copy and initiate translation of that page into target Languages.      Blueprints   Ability to create sites from existing Site Structure Templates and provide an ability to link and keep in sync the target site content. In addition to this they provide an ability to chose Languages and Starting content that should be copied from the Template reference.      Blueprints Language Requirement   Unlike Language-Copy tools, Blueprints require to have a site structure to have a language subfolder to be one level under the site root. The Name on of the Language folder needs to be in the format of &lt;language-code&gt; or &lt;language-code&gt;_&lt;country-code&gt;, for example en, en_US, en_us, en_GB, en_gb      The supported language code is lower-case, two-letter code as defined by ISO-639-1   The supported country code is lower-case or upper-case, two-letter code as defined by ISO 3166      Not having this pattern configuration on your site will not allow Blueprints to detect languages of your site.   Design Importer   When using Landing pages in AEM a Design Importer mechanism can be used to import a design into the current page. Design Importer mechanism provides a structured way external designers can create Designs for landing pages that then can be imported into AEM.      More Info : AEM Landing Pages and Extending and Configuring the Design Importer for Landing Pages  ","categories": [],
        "tags": [],
        "url": "/manifesto/tenants/",
        "teaser": null
      },{
        "title": "Deployment Practices",
        "excerpt":"              On This Page     Package Deployment and Replication   Deployment Cycle           Build Stage       Deploy Stage                   To be able to support CI/CD practice automation should used to minimise deployment overheads and avoid conflicts. When segregating infrastructure and security, production artifacts and environments should be replicated to other environments so that its configurations can be tested throughout normal development cycles. Practices must be continually refactored to be simple and transparent so that they can be used without manual intervention. It’s important to utilise same practices across all environments without exceptions, this ensures continuous improvement on practices as they are used by wider group of users.      The whole environment should be able to be replicated in different configurations in a local environment. Using Docker and Ansible for streamlining the deployment architecture and inventory enable consistency of environment and enables persistence of operations functions.   General practice is to only allow System Console and Package Installation in Local Dev environment. This practice ensures that all efforts to update a node persisted into Code and do not create conflict of the Node configuration state.   Package Deployment and Replication   Packages should be used to deploy system content and for bulk content operations (backup, archive, migration etc). Replication should be used to replicate content by authors during normal operations.   It’s important that package can be installed and uninstalled from a node. This is to ensure that update by the package can be rolled back in cases where testing has failed. Replicating packages from one node to another removes ability to Uninstall the package from the target node. Additionally replication of a package does not allow for additional processes to be carried out on the node during a deployment process.   Deployment Cycle   Deployment cycle is deployment steps that run automatically triggered by Code updates by developers or triggered manually or automatically by other jobs. The cycle is divided into Build and Deploy Stages. Build stage is used to respond to Code updates and carry out subsequent build processes and artifact storage. Deploy Stage is used for Deploying a particular versioned artifact to an environment.   Build Stage           Commit - Developer commits code to Repository            Pull - Jenkins monitors updates and pulls code into workspace            Build - Jenkins build the code using a Docker Container            Store - on successful build artifact is stored in Nexus       Deploy Stage           Retrieve - Jenkins deploy job retrieves a package from Nexus into workspace            Deploy - Jenkins deploys package to target Node            Test - Jenkins runs Testing job for the target Node            Push - Push project version update to repo            Cache - Optional, if docker containers are updated then containers is cached in shared docker registry         ","categories": [],
        "tags": [],
        "url": "/manifesto/deployment/",
        "teaser": null
      },{
        "title": "Technical Conventions",
        "excerpt":"              On This Page     Reference Material   Sample JS Project Namespace   Sample JS Console Log Utility Class   Sample JS Component Namespace   Sample Health Check   Sample Adaptive Image   Sample Sling Content Manipulation   Import UTF Characters using Sling           These sections that follow are samples that should be built upon to adopt to your situation. Please refer to (Conventions)[/manual/conventions/] and (Image Conventions)[/manual/image-conventions/] for more detailed descriptions of conventions that need to be considered when developing AEM components.   Reference Material   Architecture Overview 5.6.1   AEM Links   Sample JS Project Namespace   location: /etc/designs/`/js/namespace-aem-design.js   //namespace-aemdesign.js window.AEMDESIGN = window.AEMDESIGN || {}; window.AEMDESIGN.jQuery = window.jQuery || {}; window.AEMDESIGN.$ = window.jQuery || $;  ;(function ($, ns, window, undefined) { //add additional dependencies      \"use strict\";     var _version = \"0.1\";      ns.version = function () {         return _version;     };      var http = AEMDESIGN.HTTP;      $.ajaxSetup({ // necessary global modifications for ajax calls         statusCode: {             403: function(jqXHR) {                 if (jqXHR.getResponseHeader(\"X-Reason\") === \"Authentication Failed\") {                     // login session expired: redirect to login page                     http.handleLoginRedirect();                 }             }         }     });      $.ajaxSettings.traditional = true;   })(AEMDESIGN.jQuery, AEMDESIGN, this); //pass in additional dependencies   Sample JS Console Log Utility Class   location: /etc/designs/aem-design/js/aem-design.log.js   //aem-design.log.js window.AEMDESIGN = window.AEMDESIGN || {}; window.AEMDESIGN.log = window.AEMDESIGN.log || {};  (function ($, ns, window, undefined) { //add additional dependencies      //\"use strict\";     var _version = \"0.1\";     var settings = {         enableLog: false     }      ns.version = function () {         return _version;     };      ns.enableLog = function() {         settings.enableLog = true;     }      ns.disableLog = function() {         settings.enableLog = false;     }       ns.log = function (data) {          if (window.console &amp;&amp; window.console.log) {             var url = $(location).attr('href');              var traceStack;             if (typeof printStackTrace == \"function\") {                 traceStack = printStackTrace();             }             var debug = {                 \"caller\": arguments.caller,                 \"traceStack\": traceStack             };              if (settings.enableLog) {                 console.log([url,data,debug]);             }         }      };  })(AEMDESIGN.jQuery, AEMDESIGN.log, this); //pass in additional dependencies   Sample JS Component Namespace   location: /apps/aemdesign/componentX/clientslibs/js.txt   #base=js  functions.js behaviour.js   location: /apps/aemdesign/componentX/clientslibs/js/behaviour.js   //searchBox - behaviour  ;(function($, _, ko, searchBox, window, undefined) { //add additional dependencies      $(document).ready(function() {         $(\"[data-modules='Search']\").each(function() {              var base = $(this);             AEMDESIGN.log.log(\"loading search box\");             searchBox.init(base);          });     });   })(AEMDESIGN.jQuery, _, ko,  AEMDESIGN.components.searchBox, this); //pass in additional dependencies   location: /apps/aemdesign/componentX/clientslibs/js/functions.js   //searchBox - functions  window.AEMDESIGN = window.AEMDESIGN || {}; window.AEMDESIGN.components = AEMDESIGN.components || {}; window.AEMDESIGN.components.searchBox = AEMDESIGN.components.searchBox || {};  ;(function ($, _, ko, ns, window, undefined) { //add additional dependencies      \"use strict\";     var _version = \"0.1\";      ns.version = function () {         return _version;     };      ns.init = function($el) {          return $el; //chaining     };  })(AEMDESIGN.jQuery,_,ko, AEMDESIGN.components.searchBox, this); //pass in additional dependencies   Sample Health Check   package com.aem-design.health;  import java.io.IOException; import javax.servlet.ServletException; import org.apache.felix.scr.annotations.sling.SlingServlet; import org.apache.felix.scr.annotations.Property; import org.apache.sling.api.SlingHttpServletRequest; import org.apache.sling.api.SlingHttpServletResponse; import org.apache.sling.api.servlets.SlingAllMethodsServlet;  @SlingServlet(paths = \"/bin/aem-design/health\", methods = \"GET\", metatype = true) @Property(name = \"sling.auth.requirements\", value = \"-/bin/aem-design/health\", propertyPrivate = true) public class HealthServlet extends SlingAllMethodsServlet {     private static final long serialVersionUID = 636174686179L;      @Override     protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {         response.getWriter().write(\"AEM-OK\");     } }   Sample Adaptive Image   location: /apps/aemdesign/content/image/variant.responsive.jsp   &lt;a href=\"/content/geometrixx-media/en/events/andrew-novokov.html\"&gt;     &lt;div data-picture data-alt='Interview with Russian author Andrew Novokov'&gt;         &lt;div data-src='/content/geometrixx-media/en/events/andrew-novokov.image.370.150.medium.jpg' data-media=\"(min-width: 1px)\"&gt;&lt;/div&gt;         &lt;div data-src='/content/geometrixx-media/en/events/andrew-novokov.image.480.190.medium.jpg' data-media=\"(min-width: 480px)\"&gt;&lt;/div&gt;         &lt;div data-src='/content/geometrixx-media/en/events/andrew-novokov.image.770.300.medium.jpg' data-media=\"(min-width: 768px)\"&gt;&lt;/div&gt;         &lt;div data-src='/content/geometrixx-media/en/events/andrew-novokov.image.940.340.high.jpg'   data-media=\"(min-width: 980px)\"&gt;&lt;/div&gt;         &lt;div data-src='/content/geometrixx-media/en/events/andrew-novokov.image.1170.400.high.jpg'  data-media=\"(min-width: 1199px)\"&gt;&lt;/div&gt;         &lt;noscript&gt;             &lt;img src='/content/geometrixx-media/en/events/andrew-novokov.image.370.150.low.jpg' alt='Interview with Russian author Andrew Novokov'&gt;         &lt;/noscript&gt;     &lt;/div&gt; &lt;/a&gt;   location: /apps/aemdesign/content/image/clientslibs/js/functions.js   $(\"div[data-picture]\", context).each(function () {     var currentPicture = this;     var matches = [];     $(\"div[data-media]\", currentPicture).each(function () {         var media = $(this).attr(\"data-media\");         if (!media || ( w.matchMedia &amp;&amp; w.matchMedia(media).matches )) {             matches.push(this);         }     });      var $picImg = $(\"img\", currentPicture).first();      if (matches.length) {         if ($picImg.size() === 0) {             var $currentPicture = $(currentPicture);             $picImg = $(\"&lt;img /&gt;\").attr(\"alt\", $currentPicture.attr(\"data-alt\")).appendTo($currentPicture);         }         $picImg.attr(\"src\", matches.pop().getAttribute(\"data-src\"));     } else {         $picImg.remove();     } });   Sample Sling Content Manipulation   Sling allows ability to automate content creation, deletion and updates.   Sling API Manipulation Manual : http://sling.apache.org/documentation/bundles/manipulating-content-the-slingpostservlet-servlets-post.html   Import UTF Characters using Sling   curl -X POST -u \"admin:admin\" -F\"_charset_=utf-8\" --form-string \"text-ja=あなたが喜んで学ぶならば、誰かが喜んで教えるでしょう！。\" http://localhost:4502/content/testpage/jcr:content/par/label  ","categories": [],
        "tags": [],
        "url": "/manifesto/technical/",
        "teaser": null
      },{
        "title": "Manual",
        "excerpt":"Document Purpose   The purpose of this document is to introduce you to the AEM Platform and of its related projects, tools and processes. This knowledge is required to maintain and extend the AEM Platform.   Table of Contents                                                                                                                                      Projects                                                                              Development Tools                                                                              Management                                                                              Operating Environment                                                                              Process                                                                              Conventions                                                                              Image Conventions                                                                              Design Language System                                                      ","categories": [],
        "tags": [],
        "url": "/manual/",
        "teaser": null
      },{
        "title": "Projects",
        "excerpt":"              On This Page     Projects           Overview       Ansible Deploy Project                   Ansible Project Overview           Ansible Variables           Group Variables           Source Code Repositories                       Adobe Experience Manager Project                   AEM Project Sources           AEM Service Bundle           AEM Configuration                           OSGi Run modes               Environment Config Content                                   AEM Initial Content                       Virtual Machine Project                   Packer Project Overview                           Packer Project Structure                                   Using Packer                           Packer Installation               Packer Command                                   Machine Image Builds                           Local Image Build               SIT Image Build               Staging Image Build               Production Image Build                                   Updating a Machine Image                                   Projects   Overview   There are three primary project sources in the AEM implementation:           Ansible Deploy Project - used to contain all of the ansible playbooks for managing AEM docker services            Virtual Machine Project - used to create VM hosts using packer.io.            docker-aem - docker container used to run local AEM instances.       The following sections will highlight their key design decisions and their implementation details.   Ansible Deploy Project   The aemdesign-deploy project is a server automation project using Ansible to deploy and configure services. The project also contains scripted operational tasks for maintaining the operating system and services..   Before proceeding, this section contains content with assumed Ansible knowledge. Recommended starting points are ‘Intro to Playbook*s’ (NOTE:  http://docs.ansible.com/ansible/latest/playbooks_intro.html) and *‘**Intro to Inventorie*s’* (NOTE:  http://docs.ansible.com/ansible/latest/intro_inventory.html) in the Ansible online documentation.   This project is implemented with the following features and their concepts are required to maintain the project:           Roles (http://docs.ansible.com/ansible/latest/playbooks_roles.html)            Tags (http://docs.ansible.com/ansible/latest/playbooks_tags.html)            Variables (http://docs.ansible.com/ansible/latest/playbooks_variables.html)       Additional topics on Ansible, can be found in the online documentation.   The aemdesign-deploy project is implemented using the standard Ansible layout. Anyone familiar with Ansible should also be familiar with this implementation layout.   An implementation specific overview is provided in the following section.   Ansible Project Overview   The recommended operating system for the aemdesign-deploy project is either MacOS or a distribution of Linux such as Red Hat and Ubuntu.                  Path       Description                       /       Playbooks for site, group and operations are located at the root of the project. This is discussed in detail in the Playbooks section.                 /inventory       The inventory defines servers (defined as a SSH host). The servers provide the automation scripts with machine targets to deploy and configure services. In the aemdesign-deploy project, servers are typically Red Hat Enterprise Linux servers with a Docker service and Docker containers are specified in a group using an alias for the target machine. The inventories are organised into environments in a group var (group_vars/[environment_name]/vars.yml) which specifies environment specific configurations. See for Testing Environments for inventory details.                 /roles       A role is a reusable unit of work that is composed of serial tasks. For example, a role can create a logical volume or start a web server in a Docker host.                 /group_vars       There are two categories of group vars; application and environment. Typically, application group vars are used to override the default variables defined within roles. The environment group vars are used to define environment specific variables by overriding the group variables. This is represented as a hierarchy within the inventories as groups with the ‘:children’ suffix.                 /host_vars       These are variables for servers that form the site and they are shared across all environments. This means that automation scripts apply the same host vars in each environment which ensures all environments are similar to each other.                 /library       Custom modules developed for the project. Modules have been developed to orchestrate AEM and Docker.           Ansible Variables   Table of variable descriptions.                  Variable       Description                       docker_image_tag       Common variable name used  in roles for specifying which Docker image version to run.           Group Variables   For each role,  there is  group variable that overrides the default variable defined in the role. Within each file, there is the variable *docker_image_tag *that can be updated to change the version of the Docker image to run.                  Role       Group Variable       Role / Files / Dockerfile                       publisher       /aemdesign-deploy/group_vars/publisher/vars.yml       /aemdesign-deploy/roles/aem/files/docker/aem                 author       /aemdesign-deploy/group_vars/author/vars.yml       /aemdesign-deploy/roles/aem/files/docker/aem                 consul-client       /aemdesign-deploy/group_vars/consul-client/vars.yml       consul:latest                 dispatcher       /aemdesign-deploy/group_vars/dispatcher/vars.yml       /aemdesign-deploy/roles/dispatcher/files/docker/dispatcher                 esb       /aemdesign-deploy/group_vars/esb/vars.yml       /aemdesign-deploy/roles/mule-esb/files/docker/muleesb                 solr       /aemdesign-deploy/group_vars/solr/vars.yml       /aemdesign-deploy/roles/solr-cloud/files/docker/aem-solr                 processing       /aemdesign-deploy/group_vars/processing/vars.yml       /aemdesign-deploy/roles/aem/files/docker/aem                 consul-server       /aemdesign-deploy/group_vars/consul-server/vars.yml       consul:latest                 nexus       /aemdesign-deploy/group_vars/nexus/vars.yml       /aemdesign-deploy/roles/nexus/files/docker/nexus           Source Code Repositories                  Repo       Notes                       aemdesign-parent/       root repo for devops script and automation                 aemdesign-aem-author/       changes to authoring experience                 aemdesign-aem-common/       common components                 aemdesign-aem-config/       configuration for author and publishers                 aemdesign-aem-content/       initial content                 aemdesign-aem-services/       services for author and publisher                 aemdesign-aem-showcase/       showcase content                 aemdesign-aem-training/       training site content                 aemdesign-deploy/       deploy project, contains all docker files                 aemdesign-devbot/       used to control devops script remotely                 aemdesign-docker/       parent docker project, outdated                 aemdesign-esb-mule/       esb implementation                 aemdesign-jenkins/       jenkins backup                 aemdesign-prototype/       font-end prototype project                 aemdesign-security/       security for hardening not Atomic hosts                 aemdesign-testing/       testing suite                 aemdesign-vm/       vm templating           Adobe Experience Manager Project   Adobe Experience Manager (AEM) Project Source Code and Content Packages           AEM Project Sources            AEM Service Bundle            AEM Configuration            AEM Initial Content       AEM Project Sources   The AEM Project Sources contain AEM 6.1 components, client libraries (HTML, CSS and JavaScript) and AEM lib overlays (NOTE:  AEM overlays https://docs.adobe.com/docs/en/aem/6-3/develop/platform/overlays.html).   AEM Service Bundle   The AEM Service Bundle contains Java sources for OSGi services and components that extend or add functionality to AEM.   AEM Configuration   The AEM Configuration project contains configurations (NOTE:  OSGi configuration https://docs.adobe.com/docs/en/aem/6-3/deploy/configuring/configuring-osgi.html) for AEM OSGi services as well as the OSGi services developed in the aemdesign-aem-services module.   For environment specific configurations, apply them with run modes to activate configurations. These environment run modes are configured:           localdev            develop            sit            uat            training            staging            Production       These server run modes are configured:           author            publisher            processing       OSGi Run modes   The path to the run mode configurations is located at:   config/src/main/content/jcr_root/apps/aemdesign   These run modes are configured for the AEM servers and environments:           config.author            config.author.develop            config.author.localdev            config.author.processing            config.author.processing.develop            config.author.processing.localdev            config.author.processing.sit            config.author.production            config.author.sit            config.author.staging            config.author.training            config.author.uat            config.publish       By default it will use the AEM server run mode, the OSGi service definition XMLs in config.author, **config.publisher and **config.author.processing. Each environment can override them by specifying a OSGi service definition XML in the corresponding environment run mode.   More information can be found in the online documentation Deploying and Maintaining, Configuring, Run Modes (NOTE:  https://docs.adobe.com/docs/en/aem/6-3/deploy/configuring/configure-runmodes.html).   Environment Config Content   The AEM Configuration project produces one configuration file per environment. This is to configure AEM components that are not OSGi based. For example, the following AEM configurations:           Cloud Configs            Replication Agents       These configuration packages are created:           aemdesign-aem-config-[release_version]-develop.zip            aemdesign-aem-config-[release_version]-production.zip            aemdesign-aem-config-[release_version]-sit.zip            aemdesign-aem-config-[release_version]-staging.zip            aemdesign-aem-config-[release_version]-training.zip            aemdesign-aem-config-[release_version].zip       AEM Initial Content   The AEM Initial Content project contains content that is required for a functioning site. It also enables transportable content between testing environments.   Virtual Machine Project   The aemdesign-vm project uses Packer by HashiCorp to automate machine image creation.   To learn more about Packer, refer to the online documentation (NOTE:  https://www.packer.io/docs/index.html).   The project was built using VirtualBox Version 5.1.10. The binaries are available for download at: https://www.virtualbox.org/wiki/Downloads   Packer Project Overview   The project is designed to build on Centos and has built and provisioned Centos versions 7+ for deployment on private datacenter infrastructure.   While the datacenter servers are running on VMWare virtualisation, the local development image is built for VirtualBox.   Packer Project Structure                  Path       Content                       Path       Content                 /       Templates with build configuration for the machine image automation                 http/       Path to the configuration files for the HTTP server during Machine Image creation. The Anaconda Kickstart scripts configures RHEL7 in an non-interactive environment (the template file’s builder variable boot_command is used to execute the script). Kickstart Syntax Reference                 http/iso       Path to Red Hat Enterprise Linux 7 Full ISO for building the machine image                 scripts/       Shell scripts executed as provisioners during the build                 scripts/common       Scripts common to all machine image builds                 scripts/devops       Scripts to install and configure devops services such as Docker                 scripts/rhel       Scripts to configure Red Hat Enterprise Linux                 settings/       Setting variable files to customise machine images. Overrides variables defined in the build templates           Using Packer   Packer Installation   In the aemdesign-vm project,   npm install &amp;&amp; ./packer.io/install   Packer Command   The Packer command requires two json configuration files to build a machine image,   ./bin/packer build -var-file=./settings/[variables].json [template_file].json   Where           template_file* *is the configuration for the build            variables overrides the “variables” section in the template_file       The template_file* *build configuration files can be found in the project’s root path. The variables file overrides values defined in the template_file. This enables the customisation of images.                  Template File       Actions                       centos-vbox.json       Builds a VM Machine Image, configures a NAT network interface and installs VM tools           Machine Image Builds   Note: For best results please pass params to packer instead of using settings files, this will keep repo clean   Local Image Build   ./bin/packer build -var-file=./settings/variables-online.json template-rhel-build-virtualbox-localdev.json   SIT Image Build   ./bin/packer build -var-file=./settings/variables-online-sit.json template-rhel-build-virtualbox-server.json   Staging Image Build   ./bin/packer build -var-file=./settings/variables-online-stage.json ./templates/centos-vbox.json   Production Image Build   ./bin/packer build -var-file=./settings/variables-online-prod.json ./templates/centos-vbox.json   Updating a Machine Image   Note: Packer will download and cache ISO file first time, follow this if you want manual control over this process           Download a Centos ISO            Copy it to ./*http/iso/ *in the aemdesign-vm project.            Update the iso_url* variable *to path of the ISO:       3.1  from “iso_url”: “http://ftp.swin.edu.au/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1708.iso”,       3.2. to “iso_url”: “http/iso/your-iso-name.iso”            Update the iso_checksum* *variables to match the ISO:       4.1. from “iso_checksum”: “ec7500d4b006702af6af023b1f8f1b890b6c7ee54400bb98cef968b883cd6546”       4.2. to “iso_checksum”: “your-iso-sha256-checksum”      ","categories": [],
        "tags": [],
        "url": "/manual/projects/",
        "teaser": null
      },{
        "title": "Development Tools",
        "excerpt":"              On This Page     Development Tools           Git       Apache Maven                   Package Build                           Local Development Build               Local Development Service Module Build               Local Development Common Module Build               Local Development Config Module Build               Local Development Content Module Build               Full Build and Deploy to Repository                                   JGitFlow Plugin                           Plugin Usage                                               Ansible Playbooks                   Site Playbooks                           site.yml               site-teardown.yml               site-devops.yml                                   Operations Playbooks                           operation-aem-deploy.yml               operation-esb-deploy.yml               operation-oak-compaction.yml               operation-volume-fstrim.yml                                   Group Playbooks                           Server Playbooks               Application Playbooks                                   Management Playbooks           Libraries                                   Development Tools   Git   The projects sources are managed with Git.   Apache Maven   Maven manages the build lifecycle for the AEM content packages, service bundles and configurations, as well their dependencies. Maven 3.5.0 was used during the development of the project.   The content package projects uses ‘content-package-maven-plugin’ to create a CRX content package.   The project was originally created using the ‘CQ Project Maven Archetype’ (http://www.cqblueprints.com/setup/maven.html).   The AEM project contains 4 child modules:           aemdesign-aem-common              Embeds aemdesign-aem-services under /apps/aemdesign/install                aemdesign-aem-services            aemdesign-aem-config              Creates a configuration package per environment                aemdesign-aem-content       Package Build   Maven commands when run in the aemdesign-aem project.   Local Development Build   mvn -PautoInstallPackage clean package   Local Development Service Module Build   mvn -pl services clean package   Local Development Common Module Build   mvn -pl common clean package   Note: this embeds the last built service module. To ensure the latest build, use -pl services,common in the command parameters and the order of the modules is important.   Local Development Config Module Build   mvn -pl config clean package   Local Development Content Module Build   mvn -pl content clean package   Full Build and Deploy to Repository   mvn clean deploy   JGitFlow Plugin   The JGitFlow Maven Goals manages the Git Flow branching strategy.  The table below lists common usages of the JGitFlow. All commands are run in the ‘aemdesign-aem-dam’ parent module.                  Maven Goals       Actions                       mvn jgitflow:feature-start       Creates and checks out the new feature branch from /develop                 mvn jgitflow:feature-finish       Merges the current working feature branch into /develop and deletes the feature branch                 mvn jgitflow:release-start       Creates a new /release/[build_version] branch from /develop                 mvn jgitflow:release-finish       Creates a tag named version/[build_version] from /release/[build_version] and merges /release/[build_version] back into /develop and /master. Finally, JGitFlow deletes /release/[build_version]. This ensures that there is only one release in any point in time                 mvn jgitflow:hotfix-start       Creates a new /hotfix/[build_version] branch from /master                 mvn jgitflow:hotfix-finish       Creates a tag named version/[build_version] from /hotfix/[build_version] and merges /hotfix/[build_version] back into /develop and /master. Finally, JGitFlow deletes /hotfix/[build_version]           Plugin Usage   Branching is not be intended to be limited to the JGitFlow Maven Goals. Its underlying actions are standard Git commands and as such they can be repeated with the git command line tool. Also, there are cases where the git command line tool is required. One such case is when a new feature is required in the current release, in which case the feature is branched from /release/[build_version] and not /develop. Another case is resolving conflicts during branch merging.   For details on Git Flow, see the Processes section on Git Flow   For additional details on the plugin https://bitbucket.org/atlassian/jgit-flow/wiki/Home.   Ansible Playbooks   There are three types of playbooks that perform automated tasks; operation playbooks, group playbooks and site playbooks. A group playbook provisions servers and applications while a site playbook provisions an entire platform. The site playbook will typically run a few group playbooks which will form the platform. Operation playbooks performs regular tasks on groups such as repository maintenance and package deployments.   By convention, the group playbooks are named after the group vars and site playbooks are prefixed with ‘site-‘.   Site Playbooks   site.yml   The site playbook manages the AEM platform and its testing environments with the use of inventories.   The following playbook command will provision a complete site using the local development inventory,   ./devops accesslocal   or:   ansible-playbook -i inventory/localdev site.yml --user aemdesign --private-key ../aemdesign-vm/keys/current/aemdesign   A well designed playbook should perform all tasks required to provision a site in a single command. However, there are scenarios where only a part of the playbook is required. It is possible to activate a subset of tasks by running a playbook with tags. For example, by adding the –tags parameter to the ansible-playbook command.   The following are tags that are in use:           docker-host-stop-containers            docker-host-stopped            docker-images-build            Install-packages       To list all tags in the site playbook,   ansible-playbook site.yml --list-tags   Similarly, playbooks may skip parts of the play with the use of the –skip-tags parameter. For example, in cases where the Docker images are built separately, a playbook that is provisioning a site may decide not to rebuild the images and instead pull them from a Docker registry.   The practice of tagging tasks is best done during the development of roles. This allows the developer to not only exercise the new roles but also test that tags work in isolation.   A recommended approach in developing playbooks is to start with the localdev inventory and promote the changes through each of the environments. The project is designed with roles, groups and host variable precedence to facilitate this development process.   The following environments have inventories configured (in order of promotion):           localdev            develop            sit            uat            training            staging            production       The platform consists of servers and services. In order to provision the platform, the site playbook includes the following group playbooks that perform the actual provisioning:           convoy.yml              See Convoy Volume Plugin                server.yml            applications.yml            solr.yml            author.yml            publisher.yml            processing.yml            dispatcher.yml            esb.yml       site-teardown.yml   Teardown playbook is for removing all applications and their data in a Docker host. Its purpose is to prepare the servers such that a new site can be provisioned without any dependencies on a previous state.   For example, it can be used to rebuild the develop environment on a daily basis and/or prepare the UAT environment before each test cycle.   Sample usage,   ansible-playbook -i inventory/localdev site-teardown.yml --user aemdesign --private-key ../aemdesign-vm/keys/current/aemdesign   site-devops.yml   Deploys and configures the Management services.   Operations Playbooks   operation-aem-deploy.yml   Installs versioned AEM content packages from a Maven repository to each of the authors, publishers and processing servers defined in the inventory.   operation-esb-deploy.yml   Installs versioned ESB packages from a Maven repository to the Mulesoft ESB hot deploy folder ‘/opt/mule/apps’.   operation-oak-compaction.yml   Operations playbook that implements the revision cleanup for the AEM Repository. Refer to the Adobe’s online documentation under ‘*Maintaining the Repository *‘for the significance of this operation:   https://docs.adobe.com/docs/en/aem/6-3/deploy/platform/storage-elements-in-aem-6.html   operation-volume-fstrim.yml   Operations playbook to releasing unused blocks used by Convoy thinly provisioned volume. (refer to: Thin Volume Management).   Group Playbooks   There are two group playbooks. Tasks that maintain the server and tasks that manages an application.   Server Playbooks                  Playbook       Actions                       server.yml       Configures Red Hat Enterprise Linux servers. The following tasks are performed (role references in parenthesis), Adding Network Interfaces before other roles requiring network connectivity ( server-network-interfaces). Installation of RPMs using YUM Installation of security updates Installation of Python Packages required by Ansible (python-packages) Configuration of the Docker service  (docker-host) Configuration of Docker networks (docker-network) Configuration of Server IPTables (server-iptables)                 applications.yml       Configures common services for the Docker service and its containers. Deploys Consul servers Deploys Consul clients Deploys a Registrator service for all Consul servers and clients                 convoy.yml       Deploys and configures the Convoy Docker plugin. Creates a data device in the rhel volume group Creates a metadata device in the rhel volume group Installs Convoy as a system service Stats the Convoy system service           Application Playbooks                  Playbook       Actions                       author.yml       Automates the deployment and configuration of AEM authors. Deploys AEM Installs AEM Content Packages such as, Feature Packs Hotfixes ACS Commons 3rd Party Content Packages Configures Replication Agents Configures Workflows                 publisher.yml       Automates the deployment and configuration of AEM publishers. Deploys AEM Installs AEM Content Packages such as, Feature Packs Hotfixes ACS Commons 3rd Party Content Packages                 dispatcher.yml       Deploys and configures an author and publisher dispatcher. Builds and configures the author and publisher dispatcher services Starts the services                 esb.yml       Deploys and configures the ESB service                 processing.yml       Automates the deployment and configuration of AEM processing. Deploys AEM Installs AEM Content Packages such as, Feature Packs Hotfixes ACS Commons 3rd Party Content Packages                 solr.yml       Deploys and configures Solr Cloud service           Management Playbooks   Deploys and configures management services in the AEM DAM Platform.  These are devops services such as,           Jenkins            Nexus       These are discussed in detail in the Development Tools section.   Libraries   Ansible Modules adding AEM and Docker tasks to Playbooks.   Python source code for the modules can be found under the project location; ‘aemdesign-deploy/library/ansible-modules’.                  Module       Action                       aem_bundles_wait_activated.py       Polls AEM at ‘/system/console/bundles.json’ until ALL bundles are activated                 docker_containers.py       Starts or stops ALL Docker containers on a server                 docker_images.py       Removes ALL Docker images on a server                 docker_volumes.py       Removes ALL Docker volumes on a server           There are additional modules in the project. They are omitted as they are documented in https://github.com/wildone/pyaem.  ","categories": [],
        "tags": [],
        "url": "/manual/devtools/",
        "teaser": null
      },{
        "title": "Management",
        "excerpt":"              On This Page     Jenkins           Operations                   fstrim (environment)           Oak Compaction (environment)           Shutdown (environment)           Startup (environment)           Teardown (environment)                       Packages                   aemdesign-aem build (develop)           aemdesign-aem build (release)           aemdesign-aem build (final)           aemdesign-aem deploy (environment)                       Playbooks                   Site Playbook (develop|sit|staging|training|uat)                       Playbooks Production                   Startup (Production)           Shutdown (Production)           Site Playbook (Production)                           Nexus           Configuring Nexus       Maven Repositories       Docker Registries                   Jenkins   http://192.168.27.2:8080/   The Jenkins role is as an automation server for the AEM platform. It is primarily used to trigger Ansible playbooks and Maven builds. The jobs are configured to discourage automation logic in Jenkins and to encourage the development in the playbooks. This keeps the playbooks portable.   A well designed playbook should “run everywhere” without further intervention i.e. running a playbook on a developer machine should be the same as on Jenkins.   The following sections will detail the types of jobs configured in Jenkins, and its invocation of Playbooks and Maven commands.   Operations   The Operations view is a collection of operational jobs. These are intended to run regularly, whether on a schedule or on an ad hoc basis, such as AEM maintenance tasks and server startups/shutdowns.   fstrim (environment)   Scheduled operational job to execute fstrim on mounted file systems managed by thin volumes provisioned by Convoy.   Runs the playbook operation-volume-fstrim.yml.   See the section Thin Volume Management for background information.   Oak Compaction (environment)   An operational job to schedule revision cleanup on the repository.   Runs the playbook operation-oak-compaction.yml   Shutdown (environment)   Operational job to gracefully stop running Docker containers and then stop the Docker service.   This job can be used in a backup process pipeline where the application state needs to be in a non-transactional state.   Runs the playbook site.yml and limits tasks to the application group and tasks with tags docker-host-stop-containers and docker-host-stopped.   Startup (environment)   Operational job to start the Docker service and start the Docker containers.   Runs the playbook site.yml and limits the tasks to the application group, and tasks with tags docker-host-start-containers and docker-host-started.   Teardown (environment)   An operational job to stop and remove all running Docker containers and their volumes. Additionally, will also remove all pulled Docker images from the local registry   Runs the playbook site-teardown.yml.   Packages   The Packages view contains jobs that build from the Git Flow branches (/develop, /release/[build_version], /hotfix/[build_version]) and tags, and installs content packages to the AEM servers.   All build artifacts are deployed and pushed to the Nexus repository,   aemdesign-aem build (develop)   The develop build job polls for changes in the Git repository and triggers a Maven build on the /develop branch. The built AEM Content Packages are deployed to Nexus as Maven snapshot artefacts.   aemdesign-aem build (release)   The release build job triggers a Maven build from the */release/** branch on demand. The AEM Content Packages built are deployed to Nexus as Maven snapshot artefacts.   aemdesign-aem build (final)   The final build triggers a Maven build from */tag/[BUILD_TAG] *where BUILD_TAG is a build parameter. The AEM Content Packages produced are deployed to Nexus as Maven final artefacts.   aemdesign-aem deploy (environment)   Jobs suffixed with ‘deploy’ updates the AEM application and configuration by pulling the latest AEM snapshot content packages from Nexus and installs them on AEM on a per *environment *basis. The following projects are installed (in order of installation):           aemdesign-aem-common            aemdesign-aem-config            aemdesign-aem-content       Playbooks   Site Playbook (develop|sit|staging|training|uat)   Jobs to provision the AEM Platform in each of the specified environments. They are configured to skip the Docker Image build as they are built separately.   Playbooks Production   Startup (Production)   Job to gracefully start all stopped Docker containers in Production.   Shutdown (Production)   Job to gracefully stop all running Docker containers in Production.   Site Playbook (Production)   Job to provision the AEM Platform in Production. They are configured to skip the Docker Image build as they are built separately.   Nexus   Maven Artefact and Docker Image repository of packages.   Configuring Nexus   Consult the online documentation (NOTE:  https://help.sonatype.com/) for specific details on configuring Nexus. The AEM Platform has configured Nexus for the:           Maven Repositories (NOTE:  https://help.sonatype.com/display/NXRM3/Maven+Repositories)            Docker Registries (NOTE:  https://help.sonatype.com/display/NXRM3/Private+Registry+for+Docker)       Maven Repositories                  Repository URL       Content                       http://192.168.27.2:8081/repository/maven-releases/       internal repository for release artifacts                 http://192.168.27.2:8081/repository/maven-snapshots/       internal repository for snapshot artifacts                 http://192.168.27.2:8081/repository/maven-repo/       A proxy for: Repository Maven Central Adobe Public Repository                 http://192.168.27.2:8081/repository/maven-repo/       A proxy for: Maven Central Adobe Public Repository WCM IO Repository           Docker Registries                  Repository URL       Content                       http://192.168.27.2:5000       private registry for Docker images           ","categories": [],
        "tags": [],
        "url": "/manual/management/",
        "teaser": null
      },{
        "title": "Operating Environment",
        "excerpt":"              On This Page     Server           Red Hat Enterprise Linux                   IPTables           Thin Pool           Thin Volume Management                       Docker                   Convoy Volume Plugin                           List Managed Volumes               Create Volume               Delete Volume                                   Docker Images                           Updating Docker Images                                   Consul           Registrator                                   Server   Red Hat Enterprise Linux   The following sections details the configuration of Red Hat Enterprise Linux in accordance with the operability of the devops services such as Docker. Topic areas include:           Network security and IPTables            Data management with Thin Pools and Thinly Provisioned Volumes       IPTables   The servers are configured with the IPTables service. The initial configuration is applied in the Virtual Machine Project in the script aemdesign-vm/scripts/devops/firewall.sh.   The IPTables rules are specified within the applications group var in the aemdesign-deploy project using the ‘*iptable’ *variable,   group_vars/applications/vars.yml   The role ‘server-iptables’ automates the application of the configuration in the Using the IPTables service (NOTE:  https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_iptables.html) of the Red Hat Product Information.   The configuration of IPTables is not strictly required for the Docker containers that bind to the host IP and port. The Docker service will forward packets from the statically assigned IP network interface eth0 to the network interface docker0 *that binds to the Docker bridge network (under the Virtual Machine Project and in the file  *aemdesign-vm/scripts/devops/firewall.sh)   The IPTables rules for applications that are installed as services on the operating system are required to be defined.   Thin Pool   A Thin Pool named ‘rhel’ is configured in the aemdesign-vm project as part of the initial Docker installation. Details on the installation can be found ‘aemdesign-vm/scripts/devops/docker-install.sh’.   Each server is configured with Convoy (NOTE:  Convoy project home: https://github.com/rancher/convoy) which is used in Docker as a volume plugin. Convoy is a Docker Plugin that wraps a thin pool backed by the kernel level Device Mapper (NOTE:  Red Hat Device Mapper documentation : https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/device_mapper.html). The Docker containers in the AEM Platform are configured to use Convoy to manage their data.   Thin Volume Management   As the Docker containers write and delete data in the logical volumes, blocks allocated by the thin pool are not released immediately. This is by design as a security and as a performance concern. The security concern is as blocks are marked as unused, the blocks may contain sensitive data that can be read by another process when released. The thin pool can ‘zero out’ the data block but this is a performance concern as a delete will incur a corresponding write operation.   A recommended way to ensure unused blocks are eventually released, is to schedule a regular job to execute the command *‘fstrim’** *on the mounted file systems. This command returns unused blocks to the thin pool.   See operation-volume-fstrim.yml.   Docker   Docker is configured to manage applications using thin pool volume data management via Convoy.   The service is installed via the Virtual Machine Project project in the script ‘aemdesign-vm/scripts/devops/docker-install.sh’.   Convoy Volume Plugin   As Convoy is configured as a Docker volume plugin, it is not required to use the ‘convoy’ command line tool. Docker calls the Convoy API as part of the container lifecycle API to create and delete Docker volumes.   The following convoy command output demonstrates the ‘wrapping’ of the Device Mapper i.e. the dmsetup command.   List Managed Volumes   convoy list   output:   \"consul-client\":{ \t\"Name\": \"consul-client\", \t\"Driver\": \"devicemapper\", \t\"MountPoint\": \"/var/lib/rancher/convoy/devicemapper/mounts/consul-client\", \t\"CreatedTime\": \"Mon Jul 24 15:28:08 +0800 2017\", \t\"DriverInfo\": { \t\t\"DevID\": \"10\", \t\t\"Device\": \"/dev/mapper/consul-client\", \t\t\"Driver\": \"devicemapper\", \t\t\"Filesystem\": \"ext4\", \t\t\"MountPoint\": \"/var/lib/rancher/convoy/devicemapper/mounts/consul-client\", \t\t\"Size\": \"107374182400\", \t\t\"VolumeCreatedAt\": \"Mon Jul 24 15:28:08 +0800 2017\", \t\t\"VolumeName\": \"consul-client\" \t}, \t\"Snapshots\": {} }   Create Volume   convoy create [volume_name]   Delete Volume   convoy delete [volume_name]   Docker Images   NOTE: These images will be migrated to aemdesign-docker and will be available on https://hub.docker.com/u/aemdesign                  Role       Deploy Project Source Path                       AEM       aem/files/docker/aem                 AEM Base       aem-base/files/docker/aem-base                 AEM Dispatcher       dispatcher/files/docker/dispatcher                 Oracle JDK       docker-image-oracle-jdk/files/docker/oracle-jdk                 Jenkins       jenkins/files/docker/jenkins                 Jenkins Base       jenkins/files/docker/jenkins-base                 Nexus       nexus/files/docker/nexus                 Mulesoft ESB       mule-esb/files/docker/muleesb                 Solr Cloud       solr-cloud/files/docker/aem-solr           Updating Docker Images   The high level process for updating a Docker image is as follows:           Develop the Dockerfile for the service (https://docs.docker.com/engine/reference/builder/).            Create a new version folder (under files/docker/[image_name]/[image_version]) in the role that is provisioning the service in the aemdesign-deploy project. Place the Dockerfile and all supporting build files in the folder.            Update the variable *docker_image_tag *using variable precedence to target environments, groups and servers.                       Update the variable in the role’s default vars (default/main.yml) if this Docker image supersedes all previous image versions. For example, the new image version contains critical application updates or an external dependency that is no longer available.                        Update the variable in the group vars (group_vars/[group_name]/vars.yml) to update the servers belonging to the group. For example, AEM authors, publishers and processing groups are running the same Docker image.                        Update the group vars for services in an environment (inventory/[environment_name]). Create a group var using the group suffix ‘:vars’ (reference: http://docs.ansible.com/ansible/latest/intro_inventory.html#group-variables). Limit the use of this approach as it is best to promote Docker images from one environment to the next environment.                        Commit the changes to the repository.            In Jenkins, under ‘Packages’,  schedule the job titled ‘Playbook Build Images’. This job will build the Docker image and deploy it to the private repository (Nexus).            In Jenkins, under ‘Playbooks’, schedule the site playbook in an environment by invoking the job ‘Site Playbook ([environment_name])’       Consul   Consul provides the AEM Platform with Service Discovery using an application level Domain Name System (DNS). Online documentation can be found here: https://www.consul.io/docs/index.html.   Consul abstracts the underlying network details from the AEM platform. This design allows the playbooks to reference a single configuration regardless of environment. Additionally, this reduces the amount of configuration to maintain.   Registrator   Automatic Docker service registration for service discovery in Consul.  ","categories": [],
        "tags": [],
        "url": "/manual/osenv/",
        "teaser": null
      },{
        "title": "Process",
        "excerpt":"              On This Page     Git Flow           Versioning           Testing Environments           Git Flow   The project source code is managed with Git Flow as the release management strategy. In Git Flow, there are three main branches:           /develop            /master            /release/[build_number]       The develop branch contains features that will be deployed in the next release and the master branch contains code currently deployed in production. These two branches are always active whereas the/release/[build_number] *is the **current release **and is in a perpetual cycle of create, merge and delete. The branch */release/[build_number] contains code that is due to be deployed in the current release. It is always branched from /develop and there will only be one */release/[build_number] *at any given time.   Versioning   The versioning of the branches should be as follows; suppose there has been at least one production release and the next release is in development. Then,           the version in */master *is N            /release/[build_version] is the current release which is N + 1            */develop *is the next release which is N + 2       Developers are encouraged to create feature branches instead of working directly on these three main branches.   Further information on Git Flow can be found here:   https://www.atlassian.com/git/tutorials/comparing-workflows#!workflow-gitflow   http://nvie.com/posts/a-successful-git-branching-model/   Testing Environments   The below are our environments:           develop            system integration testing            user acceptance testing            training            staging            production       The purpose of the develop environment is to integrate feature branches into the */develop *branch for testing. The activity level in the environment should be dynamic which reflects developers committing code. Business analysts and testers may also access this environment; albeit in a preview capacity.   System integration testing environment is used to test the current release. The environment marks the beginning of the collaboration between developers and testers. At this stage, the features should be nearing completion.   User Acceptance Testing (UAT) validates that the current release is functionally correct before it can be deployed into Production. UAT represent the */release/[build_number] *branch.   Building packages from the source code for production involves building the code from the tag created during UAT. The packages are built and installed using the Jenkins production deploy job.   Staging is used before the final deployment.   ","categories": [],
        "tags": [],
        "url": "/manual/process/",
        "teaser": null
      },{
        "title": "Code Conventions",
        "excerpt":"              On This Page     Philosophy for Conventions   Component Grouping and Naming   Component Variants and Badges   Component Structure   Component Client Libs Namespace Convention   Component Versioning   Component Client Libs Modules   JSP Component Template   HTL Component Template   HTL Component WCMUsePojo Class   ClientLibs Convention - JavaScript   ClientLibs Convention - CSS   Dialog Conventions           Dialog Layout       Component Artifacts Alignment           Using Tags for Styles           Style Tags Content Generator                   Philosophy for Conventions   Philosophy of AEM.Design is to empower all developers (FED/BED) to be able to achieve more without having to learn a lot more initially. This means that focus changes to providing a simplified and specific experience that allows continuous learning of AEM and framework features. As more knowledge is gained and existing structures are understood, developers can start update structures as needed.   Major principles that should be considered as you start learning      Emphases on Content - ensure that as much structure that required is converted into the content so that its changeable post-deployment, this is following Davids #1 Rule.   Abstract AEM Knowledge - generalise and abstract AEM specific knowledge into patterns that other developers can use without immediately needing to understand underlying principles.   Component Grouping and Naming - components should be named concerning their content and AEM purpose, and not about their end-use, see more details in Component Grouping and Naming.   Component Variants and Badges - ability to represent different structures of component content without having to resort to using CSS to hide available content; see more details in Component Variants and Badges.   Tags Usage - tags in AEM are specifically made to provide a mechanism to create a taxonomy of keywords that allow linking of content together. This capability is beneficial to represent Design Language keywords that contain styling nomenclature.   Component Grouping and Naming   All components used by authors without exception must be located in their designated component group folders.   components     layout (component group)         article   This structure will ensure that their components are organised and quickly found, additionally grouping provides a segmentation structure that will allow component numbers scale without creating a mess in one folder.   Following is the list of name that should be used for making component groups                  Group       Name       Description                       Analytics       analytics       components for analytics use                 Media       media       assets related components, galleries, asset lists, videos etc                 Content       content       primary components used to store authored content, content from these components is used by other components for display                 Cloud Services       cloudservices       components for cloud services                 Layout       layout       provide layout ability, grouping and structuring of content, contains layout related components                 List       list       find pages and show their data in lists                 Details       details       used to create and display custom metadata for different page types                 Widgets       widgets       used to provide client-side functionality, integrating 3rd party services                 Commerce       commerce       used for Commerce, shopping carts, checkouts, product listing etc.                 Common       common       used for shared components that are available to authors                 Forms       forms       used to contain all the components that are used in forms                 Template       template       used to store all the available Template components that include HTML page structures that are used as a base for authorable templates                 Workflow       workflow       steps that appear in workflow editor           Groups are targeted to be meaningful to Authors when creating new groups consider how to explain component groups to authors.   Component Variants and Badges   Component Variants are used as a pattern to output different HTML templates for the same component content.      Every component will have unique fields that are used by authors for content input. Usually, these fields will be tied to a specific visual representation of that content. There are scenarios where you need to be able to output different HTML structure of a component data, to achieve Component Variant pattern is used.      Each component should have at least one default Variant, and component template should provide a content-driven approach to loading new Variants see HTL Component Template for example. This allows authors to choose from a dropdown list which variant they require.   Additionally Component Variants concepts are applied as a convention to allow a component to control the display of its content in related components. This Variants concept provides a method of describing target output structures that are structured from component fields. This pattern offers a way to remove dependencies of one component on the structure of another component.      If a component needs to leverage the content of another component it used Sling selectors to call component with a specific badge name. This also allows abstracting all of the structure into content and create an Author controlled presentation pattern.   Component Structure   All component must follow consistent patterns that help everyone to understand consistency across components. Following are the conventions that are used for components.                  Node       Purpouse       Usercase       Extension                       _cq_design_dalog       Authoring dialog that will be used to configure component       mandatory       xml                 _cq_design       Primary Authoring fo interacting with component properties       mandatory       xml                 .content.xml       component authoring metadata       mandatory       xml                 _cq_editConfig.xml       component authoring configuration for Editor UI       mandatory       xml                 README.md       readme describing the component which is viewed in the Components Experience in AEM       mandatory       md                 variant.default.       default template for display       mandatory       jsp,html                 component.       default boostrap of component       mandatory       jsp,html                 badge.default.       default badge to be used by other components for representing current component content       optional       jsp,html           Component Client Libs Namespace Convention   Components that have specific clientlibs should have following client libs assigned if they will be loaded by clientlibs in template footer and headers.   Paths of component namespace should be following the location of the component path eg .components... with  repeating for each subfolder leading up to component folder.                  Namespace       Purpose                       .components.author       specifies that this component library should be loaded into global authoring clientlibs                 .components.publish       specifies that this component library should be loaded into global publish clientlibs                 .components.       specific group for the component to be used for specific usage such as component loading its own client libs           Component Versioning  Initially, when a component is created, it’s acceptable to have the component code to be located under its folder path.   components     layout         article             &lt;component structure&gt;   Where possible initial component structure should be located in the v1 subfolder, this will also ensure that the evolution of component will require marginally less effort.   components     layout         article ( sling:resourceSuperType -&gt; v1/article )             v1                 &lt;component structure&gt;   As component version grow, root component should be pointed to the specific version all existing references of component should be using. Not doing this will mean that your content pages will have hard references to component version without any Authoring way of changing that apart from reauthoring the content.   components     layout         article ( sling:resourceSuperType -&gt; v2/article )             v1                 article             v2                 article   This will ensure that all existing pages will continue working as expected and will provide a natural upgrade for all component locations. This pattern will also minimise presenting component versions to Authors as there is no simple way to describe difference to authors when they are editing.   Component Client Libs Modules  Component generic client libs should be located in the component folder.   components     layout         article             clientlibs (version agnostic client libs)                 css/                 js/                 css.txt                 js.txt             v1                 article                  clientlibs (version specific client libs)                  &lt;component structure&gt;             v2                 article                 clientlibs (version specific client libs)                  &lt;component structure&gt;   JSP Component Template   For ease of understanding component code following sections should be used as reference.                  LABEL       Description                       ** COMPONENT DEPENDECIES **       used for describing dependecies                 ** COMPONENT DECLARATIONS **                         ** COMPONENT LOGIC **                         ** COMPONENT TEMPLATING **                   Following is a sample for component bootrstap, please remove annotations when using as a template.   *** COMPONENT DEPENDECIES *** &lt;%@ page import=\"com.google.common.base.Throwables\" %&gt; &lt;%@ include file=\"/apps/aemdesign/global/global.jsp\" %&gt; &lt;%@ include file=\"/apps/aemdesign/global/images.jsp\" %&gt; &lt;%@ include file=\"/apps/aemdesign/global/components.jsp\" %&gt; &lt;% *** COMPONENT DECLARATIONS ***       final String DEFAULT_ARIA_ROLE = \"article\";       // {     //   1 required - property name,     //   2 required - default value,     //   3 optional - name of component attribute to add value into     //   4 optional - canonical name of class for handling multivalues, String or Tag     // }     Object[][] componentFields = {         {FIELD_ARIA_ROLE,DEFAULT_ARIA_ROLE, DEFAULT_ARIA_ROLE_ATTRIBUTE},         {FIELD_VARIANT, DEFAULT_VARIANT},     };       ComponentProperties componentProperties = getComponentProperties(             pageContext,             componentFields,             DEFAULT_FIELDS_STYLE,             DEFAULT_FIELDS_ACCESSIBILITY);   *** COMPONENT LOGIC ***     componentProperties.put(DEFAULT_BACKGROUND_IMAGE_NODE_NAME,getBackgroundImageRenditions(pageContext));   %&gt; *** COMPONENT TEMPLATING *** &lt;c:set var=\"componentProperties\" value=\"&lt;%= componentProperties %&gt;\"/&gt; &lt;%@ include file=\"/apps/aemdesign/global/component-background.jsp\" %&gt; &lt;c:choose&gt;     &lt;c:when test=\"${componentProperties.variant eq DEFAULT_VARIANT}\"&gt;         &lt;%@ include file=\"variant.default.jsp\" %&gt;     &lt;/c:when&gt;     &lt;c:otherwise&gt;         &lt;%@ include file=\"variant.default.jsp\" %&gt;     &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;%@include file=\"/apps/aemdesign/global/component-badge.jsp\" %&gt;    HTL Component Template   Following is a sample for component bootrstap   &lt;sly data-sly-use.component=\"design.aem.models.v2.layout.Article\"      data-sly-use.variant=\"${component.componentProperties.variantTemplate}\"      data-sly-use.background=\"aemdesign/global/templates/component-background.html\"      data-sly-use.info=\"aemdesign/global/templates/component-info.html\"&gt;       &lt;!--/* print component background */--&gt;     &lt;sly data-sly-call=\"${background.variant @ componentId=component.componentProperties.componentId, assets=component.componentProperties.bgimage.componentBackgroundAssets}\"&gt;&lt;/sly&gt;       &lt;!--/* print component variant */--&gt;     &lt;sly data-sly-call=\"${variant.variant @ componentProperties=component.componentProperties}\"&gt;&lt;/sly&gt;       &lt;!--/* print component info in edit mode */--&gt;     &lt;sly data-sly-call=\"${info.variant @ componentProperties=component.componentProperties, component=component}\"&gt;&lt;/sly&gt;   &lt;/sly&gt;   HTL Component WCMUsePojo Class   Following is a reference for component Class that will be backing each HTL component.   package design.aem.models.v2.details;   import com.adobe.cq.sightly.WCMUsePojo; import design.aem.components.ComponentProperties; import design.aem.utils.components.TagUtil; import com.day.cq.i18n.I18n; import org.slf4j.Logger; import org.slf4j.LoggerFactory;   public class PageDetails extends WCMUsePojo {       private static final Logger LOGGER = LoggerFactory.getLogger(PageDetails.class);       private ComponentProperties componentProperties = null;     public ComponentProperties getComponentProperties() {         return this.componentProperties;     }           @Override     public void activate() throws Exception {                   com.day.cq.i18n.I18n _i18n = new I18n(getRequest());           //COMPONENT STYLES         // {         //   1 required - property name,         //   2 required - default value,         //   3 optional - name of component attribute to add value into         //   4 optional - canonical name of class for handling multivalues, String or Tag         // }         Object[][] componentFields = {             {FIELD_VARIANT, DEFAULT_VARIANT},         };         componentProperties = ComponentsUtil.getComponentProperties(             this,             componentFields,             DEFAULT_FIELDS_STYLE,             DEFAULT_FIELDS_ACCESSIBILITY,             DEFAULT_FIELDS_ANALYTICS         );               } }    ClientLibs Convention - JavaScript   When writing component-specific API code in Javascript please ensure you encapsulating namespacing, that does not directly depend on external dependencies.   JavaScript for all Component JavaScript code must be divided into:      functions.js - component functions API, has all of the required static utility functions that will be used by component behaviours. These should only be functions and should not be binding to elements of the page on load events.   behaviour.js - component binding API, has all of the load events and binding to HTML, uses functions to help with structure and reusable config as required. This is the file that demonstrates how the component is attached to HTML markup.   JS modules should be located as following.   components     layout         article             clientlibs (version agnostic client libs)                 css/                 js/                     functions.js                     behaviour.js                 css.txt                 js.txt   Following is an example of a function used for component.   //search - functions window.AEMDESIGN = window.AEMDESIGN || {\"jQuery\":{}}; window.AEMDESIGN.components = AEMDESIGN.components || {}; window.AEMDESIGN.components.search = AEMDESIGN.components.search || {};   (function ($, _, ko, log, utils, ns, window, undefined) { //NOSONAR convention for wrapping all modules       \"use strict\";     var _version = \"0.1\";       ns.version = function () {         return _version;     };       ns.init = function($el) {         //INIT CODE     };   })(AEMDESIGN.jQuery,_,ko, AEMDESIGN.log, AEMDESIGN.utils, AEMDESIGN.components.search, this);   Following is an example of behaviours used for component.   //search - behaviour window.AEMDESIGN = window.AEMDESIGN || {\"jQuery\":{}}; window.AEMDESIGN.components = AEMDESIGN.components || {}; window.AEMDESIGN.components.search = AEMDESIGN.components.search || {};   (function ($, _, ko, utils, log, search, window, undefined) { //NOSONAR convention for wrapping all modules       $(document).ready(function () {           $(\"[data-modules*='search']\").each(function() {               var base = $(this);               search.init(base);             });         });   })(AEMDESIGN.jQuery, _, ko, AEMDESIGN.utils, AEMDESIGN.log, AEMDESIGN.components.search, this); //pass in additional dependencies   ClientLibs Convention - CSS   When writing CSS ensure that component Styles are added under a component namespace. Here is an example   [component] .&lt;component name&gt; { }   Dialog Conventions   Common Tabs for all component - use shared dialogs.   &lt;styleTab     jcr:primaryType=\"nt:unstructured\"     jcr:title=\"Style\"     path=\"/apps/aemdesign/global/dialog/touch/style/content/items/styleTab\"     resourceType=\"granite/ui/components/foundation/section\"     sling:resourceType=\"granite/ui/components/coral/foundation/include\"/&gt;   Use Tags as a source for your Dropdowns - will ensure that content can be updated later.   &lt;cancelinheritparent     jcr:primaryType=\"nt:unstructured\"     sling:resourceType=\"granite/ui/components/coral/foundation/form/select\"     fieldLabel=\"Cancel Inherit Parent\"     name=\"./cancelInheritParent\"     emptyOption=\"{Boolean}true\"     value=\"\"&gt;     &lt;datasource         jcr:primaryType=\"nt:unstructured\"         sling:resourceType=\"aemdesign/components/coral/datasources/tags\"         variant=\"valuelist\"         path=\"/content/cq:tags/${(empty tenant.id and empty tenantId) ? 'aemdesign' : (empty tenant.id ? tenantId : tenant.id )}/component-dialog/common/true-false\"/&gt; &lt;/cancelinheritparent&gt;   Don’t use Checkbox fields in dialogs - use Dropdowns so that it’s clear what if the user has made a selection and what defaults are   &lt;cancelinheritparent     jcr:primaryType=\"nt:unstructured\"     sling:resourceType=\"granite/ui/components/coral/foundation/form/select\"     fieldLabel=\"Cancel Inherit Parent\"     name=\"./cancelInheritParent\"     emptyOption=\"{Boolean}true\"     value=\"\"&gt; ... &lt;/cancelinheritparent&gt;   Common Component Field Spec - define component fields in an array to use with component helper function ComponentsUtil.getComponentProperties   Object[][] componentFields = {     {\"author\", pageAuthorFullName},     {\"authorUrl\", pageAuthorEmail},     {FIELD_VARIANT, DEFAULT_VARIANT} };   Common Component Field Load - this will collect and construct all fields with defaults and select Design/Policy config as defaults.   componentProperties = ComponentsUtil.getComponentProperties(     this,     componentFields,     DEFAULT_FIELDS_STYLE,     DEFAULT_FIELDS_ACCESSIBILITY);   Common Component Field Presets - use globally defined fields spect to collect content from shared tabs in dialog     For Styles Tabs and Common Fields    //COMPONENT STYLES // { //   1 required - property name, //   2 required - default value, //   3 optional - name of component attribute to add value into //   4 optional - canonical name of class for handling multivalues, String or Tag // } public static final Object[][] DEFAULT_FIELDS_STYLE = {     {FIELD_STYLE_COMPONENT_ID, \"\", \"id\"},     {FIELD_STYLE_COMPONENT_THEME, new String[]{}, \"class\", Tag.class.getCanonicalName()},     {FIELD_STYLE_COMPONENT_MODIFIERS, new String[]{}, \"class\", Tag.class.getCanonicalName()},     {FIELD_STYLE_COMPONENT_MODULES, new String[]{}, \"data-modules\", Tag.class.getCanonicalName()},     {FIELD_STYLE_COMPONENT_CHEVRON, new String[]{}, \"class\", Tag.class.getCanonicalName()},     {FIELD_STYLE_COMPONENT_ICON, new String[]{}, \"class\", Tag.class.getCanonicalName()},     {FIELD_STYLE_COMPONENT_POSITIONX, \"\", \"x\"},     {FIELD_STYLE_COMPONENT_POSITIONY, \"\", \"y\"},     {FIELD_STYLE_COMPONENT_WIDTH, \"\", \"width\"},     {FIELD_STYLE_COMPONENT_HEIGHT, \"\", \"height\"},     {FIELD_STYLE_COMPONENT_SITETHEMECATEGORY, \"\"},     {FIELD_STYLE_COMPONENT_SITETHEMECOLOR, \"\"},     {FIELD_STYLE_COMPONENT_SITETITLECOLOR, \"\"},     {FIELD_STYLE_COMPONENT_BOOLEANATTR, new String[]{}, \" \", Tag.class.getCanonicalName()}, //#3\" \" =do not store content in data attributes     {FIELD_STYLE_COMPONENT_ANIMATION_ENABLED, false},     {FIELD_STYLE_COMPONENT_ANIMATION_NAME, StringUtils.EMPTY, \"data-aos\"},     {FIELD_STYLE_COMPONENT_ANIMATION_ONCE, StringUtils.EMPTY, \"data-aos-once\"},     {FIELD_STYLE_COMPONENT_ANIMATION_EASING, StringUtils.EMPTY, \"data-aos-easing\"},     {FIELD_STYLE_COMPONENT_ANIMATION_DELAY, StringUtils.EMPTY, \"data-aos-delay\"},     {FIELD_STYLE_COMPONENT_ANIMATION_DURATION, StringUtils.EMPTY, \"data-aos-duration\"}, };   Dialog Layout   Consistent dialog pattern allow ease of understanding and experience of developing, using and training components to Authors.      Component Artifacts Alignment   All components must have a matching artifact in related artifacts. This is to ensure consistency and completeness of component delivery.      Using Tags for Styles   One of the main objectives of AEM.Design is to provide a consistent way of representing Design Languages as a taxonomy of Tags. This provides a mechanism to create Tags taxonomy by designers and then applied to components by authors.   The following image demonstrates the shared Style dialog that is applied to all components.      Following table describes each available option. Each of the options is defined in a way to be able to easily apply to Design Systems and so that it can be easily understood by Authors.                  Field       Type       Description                       ID       text       generates an Id attribute for a component                 Theme       tags       used to apply style one or a combination of nested components                 Modifiers       tags       used to apply design system tweaks to components                 Module       tags       used to apply behaviour to component                 Chevron       tags       used to apply Chevron to a component                 Icon       tags       used to apply Icon to the component                 Boolean Attributes       tags       used to apply metadata attributes                 Positions       text       used by Modules for placement of component in parent e.g. Tooltips                 Size       text       used to add width and height attributes to component           All text fields provide direct input that is added to the component wrapper. All Tag fields allow selecting multiple tags for each filed, which enables flexibility when applying styles.   Technically a component wrapper tag is trying to create the following footprint and it automated by using shared dialogs. This is reference output of share libraries to provide a consistent wrapper for all components.   &lt;div component id=\"${componentProperties.id}\"      class=\"${componentProperties.name} ${componentProperties.theme} ${componentProperties.modifier} ${componentProperties.chevron} ${componentProperties.icon}\"     style=\"width:${componentProperties.width};height:${componentProperties.height};\"      x=\"${componentProperties.x}\" y=\"${componentProperties.y}\"     data-modules=\"${componentProperties.modules}\"     ${componentProperties.booleanAttributes}&gt;&lt;/div&gt;   Furthermore using Tags allows storing style related content in a central place which can be updated by authors, using tags also has a benefit of translations and ability to change the actual value of tag class by updating tag entry.      These updates to tag authoring UI enable updating and adding values that correspond to CSS names in authoring UI.   Style Tags Content Generator   Compose project contains all of the CSS, JS and Tag YAML files that describe design being developed. This subproject is compiled and installed into AEM as a standalone package. Tag YAML files is used to specify design language mapping to CSS classes, and during compiling Tags content is generated.   A custom Content Generator is used to generate Tags from YAML file similar to flowing.   content/_cq_tags/aemdesign/component-style-icon: &amp;component-style-icon   feed/atom:     flat: true     prefix: 'fa fa-rss'     title: 'Atom'    feed/rss:     flat: true     prefix: 'fa fa-rss'     title: 'RSS'    social:     prefixes:       - facebook       - facebook-f       - instagram       - linkedin       - linkedin-in       - pinterest-p       - tumblr       - tumblr-square       - twitter       - youtube     valueFormat: fab fa-%%prefix%%     title: '%%prefix_normalised%%'   Reference Tag YAML files can be found in your Componse project and will be located in the Compose content-generator/config/core folder if you have generated using the AEM.Design Archetype.  ","categories": [],
        "tags": [],
        "url": "/manual/conventions/",
        "teaser": null
      },{
        "title": "Image Conventions",
        "excerpt":"              On This Page     Summary   Introduction   Image Restrictions   SVGs   Rendition Sizes   AEM Rendition Considerations   File Size Considerations   Component Image Map           Background - Tall       Background - Narrow       List - Card x3 (wide)       List - Card x2 (wide)       List - Card with Media       List - Card with Media (full width)       List - Card with Metadata           Implementation           Responsive: use existing renditions       Manual: responsive background with custom renditions per media query       Generate: generate new image with current image edits       Adaptive: generate new renditions with quality settings for each breakpoint       Rendition: pick suitable image rendition                   Summary   Understanding of Asset placement on pages and asset HTML presentation is crucial to saving effort for Authors and limiting the amount of manual image manipulation that would otherwise be required.   Introduction   Images are vital to great content; the ability to add images to content as well as for presentation is essential as it provides the ability to differentiate your content. Authoring ability to leverage the same Asset in a different location without additional work is crucial to authoring activities. Authors need to spend more time creating content and rely on DLS and CMS to provide the heavy lifting of Asset presentation.   Asset renditions are versions of an asset in a specific aspect ratio. Generating and caching Asset renditions provides substantial performance improvements as well as predictable capacity planning. This process starts at the Design Language System (DLS) that must set these guidelines and follow them throughout all components. These conventions must be understood by all designers, developers and all content authors, as these conventions will save a lot of effort for all involved.   Authors must be encouraged to upload the highest resolution images into DAM. This allows DAM workflows to use the original image for generating smaller renditions. As assets are uploaded to DAM a workflow is executed, and relevant renditions are generated and stored alongside the original image in DAM. The original image is restricted in its usage, due to obvious size implications, and is only displayed when renditions are missing.   Image Restrictions   The full list of supported asset types can be found at https://helpx.adobe.com/experience-manager/6-4/assets/using/assets-formats.html.   Generally, most image formats are supported by AEM and will work with the rendition workflows to create the various rendition sizes listed below. Any caveats are listed here.   SVGs   SVGs should be treated as special cases as they are best suited to logos and icons, rather than photos. Because they are vector-based, rather than rasterised, SVG’s can be scaled up or down without loss of quality. Further details can be found at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics.   SVG’s can be uploaded to the AEM DAM, and it will generate renditions, but this should be considered an edge case. The use of SVG’s should be limited to special cases such as logos and icons that are integrated into the site via code, rather than being added as a background image through the component authoring tools.   To further complicate matters, due to SVG’s being XML files, they can contain optional XML elements which are not supported by AEM and will cause the image rendition workflow to fail, rendering the image unusable in AEM.   So far the following elements have been identified:      &lt;linearGradient&gt;   Rendition Sizes   Following is reference image rendition sizes                  Rendition Name       Dimensions (width x height)       Dimensions - Retina       Responsive Media Query       Notes                       4K (UHD)       3840 x 2160       No image available       3840=(min-width: 3840px)       Retina image requires the original source image to be 8K                 2K (QHD)       2560 x 1440       No image available       2560=(min-width: 2560px) and (max-width: 3839px)       Retina image requires the original source image to be 5K                 Widescreen (HD)       1920 x 1080       Use 4K (UHD) non retina rendition       1920=(min-width: 1920px) and (max-width: 2559px)       Retina image requires the original source image to be 4K                 Extra Large       1792 x 1008       3584 x 2016       1792=(min-width: 1792px) and (max-width: 1919px)       Retina image requires the original source image to be 4K                 Large       1280 x 720       Use 2K (QHD) non retina rendition       1280=(min-width: 1280px) and (max-width: 1791px)       Retina image requires the original source image to be at least 2K                 Medium       896 x 504       Use Extra Large non retina rendition       896=(min-width: 896px) and (max-width: 1279px)                         Standard (wide)       640 x 360       Use Large non retina rendition       640=(min-width: 640px) and (max-width: 895px)                         Standard       512 x 288       1024 x 576       512=(min-width: 512px) and (max-width: 639px)                         Small       384 x 216       768 x 432       384=(max-width: 511px)                         Small (low res)       256 x 144       Use the same non-retina version               Set 30% jpeg compression quality. To be used for lazy loading.           AEM Rendition Considerations   There are a few limitations to AEMs image rendition creation that is worth being aware of:      It is not possible to generate a rendition which is larger than the original image. For example, if you upload an image which is 1280x720 (Large rendition), it will not generate any of the renditions which are bigger than this (e.g. Extra Large rendition)   For images which are not of a 16:9 aspect ratio, the image height is the dimension which maps to that set by the rendition. For example, the Standard rendition (which is set to 512x288) could become 431x288, where 288 is the same height as that specified by the rendition height, but the width changes to 431 rather than 512 so the image is not stretched/squashed.   If the maximum rendition size is increased, this size will need to be reflected in the OSGI config Day CQ DAM Buffered Image Cache. This can be set by an admin directly on the environments via /system/config/configMgr and should also be updated in the code repo.   File Size Considerations   As a reference for helping plan storage disk capacity:      1 sample 4K (3840 x 2160) 16:9 image which was originally 1.1MB in size takes up 4.8MB of disk space and consists of 18 image files (1 original and 17 rendition images).   Component Image Map   Images, when added to components as the background will need to scale to match container for the image. Larger images are selected based on the type of device which is specified using a media query.   Images, when placed into a card as an action image representing content, have a specific size that is defined in DLS, image container is smaller in size and dimension than the image. In this situation, a smaller image is selected based on the type of device which is specified using a media query.   Background - Tall   Tall background applies to tall page headers.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (UHD)       3840 x 600       4K (UHD)                                Desktop (QHD)       2560 x 600       2K (QHD)                                Desktop (Extra Large)       1920 x 600       Widescreen (HD)                                Desktop (Large)       1366 x 600       Extra Large                                Desktop       1024 x 600       Large                                Tablet       640 x 580       Large              The Large rendition is needed here because the height is a tad bit taller than other landscape components. If this wasn’t the case and it was 480px-500px then it would scale properly without over-scaling or cropping.                 Mobile       320 x 200       Small                          Background - Narrow   Narrow background applies to the background in a column.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (UHD)       3840 x 600       4K (UHD)                                Desktop (QHD)       2560 x 600       2K (QHD)                                Desktop (Extra Large)       1920 x 600       Widescreen (HD)                                Desktop (Large)       1366 x 600       Extra Large                                Desktop       1024 x 600       Large                                Tablet       640 x 580       Large              The Large rendition is needed here because the height is a tad bit taller than other landscape components. If this wasn’t the case and it was 480px-500px then it would scale properly without over-scaling or cropping.                 Mobile       320 x 200       Small                          List - Card x3 (wide)   This applies to a set of 3 cards in a row.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (Large)       352 x 210       Small                                Desktop / Tablet       260 x 160       Small                                Mobile       270 x 145       Small                          List - Card x2 (wide)   This applies to a set of 2 cards in a row.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (Large)       542 x 220       Standard (wide)                                Desktop       400 x 160       Standard                                Tablet       542 x 178       Standard (wide)                                Mobile       288 x 154       Small                          List - Card with Media   This applies to a set of cards that have media content.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (Large)       552 x 500       Medium                                Desktop       414 x 435       Medium                                Tablet       540 x 300       Standard (wide)                                Mobile       288 x 150       Small                          List - Card with Media (full width)   This applies to a set of cards that have media overlay.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (Large)       880 x 495       Medium                                Desktop       660 x 370       Medium                                Tablet       542 x 335       Standard (wide)                                Mobile       270 x 170       Small                          List - Card with Metadata   This applies to a set of cards that have metadata showing as overlay.                  Breakpoint       Dimensions       Rendition       Focal Point Overlay       Notes                       Desktop (Large)       700 x 495       Medium                                Desktop       550 x 370       Medium                                Tablet       500 x 280       Standard (wide)                                Mobile       260 x 162       Small                          Implementation   All image renditions will be stored in DAM as physical renditions. This saves time in generating these renditions on the fly and allows authoring control when required e.g. Authors can update renditions when needed.   Additionally, when selecting images for placement where available Authors will be able to choose a type of approach for rendering available renditions. Following is the outline of rendering options for images.   Responsive: use existing renditions   A default strategy for selecting an asset is a responsive image; this gives the best experience for end-users and has least authoring overhead as no selection needed to be made. By default, the template for this rendering option has a list of all configured renditions that cover all supported devices outlined in Rendition Sizes.   &lt;div itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" component=\"true\" data-layer-componentpath=\"article/par/contentblock4/par/image\" class=\"image imageTitleDescription\" role=\"banner\" id=\"image4\" data-layer-track=\"false\" data-asset-id=\"5b1dc46d-858c-4b3a-b23b-5f8b6e0e6770\" data-asset-trackable=\"true\" data-asset-licensed=\"false\" data-analytics-event-label=\"city3.jpg\" data-analytics-metatype=\"image/jpeg\" data-analytics-filename=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg\"&gt;    &lt;figure&gt;       &lt;picture&gt;          &lt;!--[if IE 9]&gt;&lt;video style=\"display: none;\"&gt;&lt;![endif]--&gt;          &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/jcr:content/renditions/cq5dam.thumbnail.48.48.png\"                  media=\"(min-width: 1px) and (max-width: 72px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/jcr:content/renditions/cq5dam.thumbnail.140.100.png\"                  media=\"(min-width: 73px) and (max-width: 210px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/jcr:content/renditions/cq5dam.thumbnail.319.319.png\"                  media=\"(min-width: 211px) and (max-width: 478px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/jcr:content/renditions/cq5dam.web.1280.1280.jpeg\"                  media=\"(min-width: 478px)\"&gt;             &lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;             &lt;img itemprop=\"contentUrl\"                  src=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/_jcr_content/renditions/cq5dam.web.1280.1280.jpeg\"                  title=\"city3.jpg\"&gt;       &lt;/picture&gt;       &lt;figcaption&gt;          &lt;h4&gt;city3.jpg&lt;/h4&gt;       &lt;/figcaption&gt;       &lt;div class=\"description\" itemprop=\"description\"&gt;Image that has no title&lt;/div&gt;    &lt;/figure&gt; &lt;/div&gt;   Manual: responsive background with custom renditions per media query   Some scenarios need for manual selection of renditions.   Following author selections allow selection of existing renditions for a specific media query, providing exceptional control to authors.      Result in generations of this picture template.   &lt;div itemscope=\"\" itemtype=\"http://schema.org/ImageObject\"      component=\"true\" data-layer-componentpath=\"article/par/contentblock24/par/image\"      class=\"image\" role=\"banner\" id=\"image24\" data-layer-track=\"false\"      data-asset-id=\"ecd9f9af-458e-4b28-afc2-3c14bacbedb8\"      data-asset-trackable=\"true\" data-asset-licensed=\"false\"      data-analytics-event-label=\"aem-design.png\"      data-analytics-metatype=\"image/png\"      data-analytics-filename=\"/content/dam/aemdesign-showcase/en/common/aem-design.png\"&gt;    &lt;picture&gt;       &lt;!--[if IE 9]&gt;&lt;video style=\"display: none;\"&gt;&lt;![endif]--&gt;       &lt;source           srcset=\"/content/dam/aemdesign-showcase/en/common/aem-design.png/jcr:content/renditions/aem-design-logo.png\"           media=\"(min-width: 768px)\"&gt;       &lt;source           srcset=\"/content/dam/aemdesign-showcase/en/common/aem-design.png/jcr:content/renditions/cq5dam.web.1280.1280.png\"           media=\"(min-width: 768px) and (orientation: landscape), screen and (min-width: 992px)\"&gt;       &lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;       &lt;img itemprop=\"contentUrl\"           src=\"/content/dam/aemdesign-showcase/en/common/aem-design.png/_jcr_content/renditions/cq5dam.web.1280.1280.png\"           title=\"aem-design.png\"&gt;    &lt;/picture&gt; &lt;/div&gt;    Generate: generate new image with current image edits   Existing image functionality allows some modification of the original image using the Generated Image options allows leveraging this functionality.      The resulting template contains a link to the current image path with a timestamp.   &lt;div itemscope=\"\" itemtype=\"http://schema.org/ImageObject\"      component=\"true\" data-layer-componentpath=\"article/par/contentblock20/par/image\"      class=\"image\" role=\"banner\" id=\"image20\" data-layer-track=\"false\"      data-asset-id=\"5b1dc46d-858c-4b3a-b23b-5f8b6e0e6770\"      data-asset-trackable=\"true\" data-asset-licensed=\"false\"      data-analytics-event-label=\"city3.jpg\"      data-analytics-metatype=\"image/jpeg\"      data-analytics-filename=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg\"&gt;    &lt;img class=\"img-fluid \" itemprop=\"contentUrl\"        src=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg.img.jpeg/1586316135756.jpeg\"        title=\"city3.jpg\"&gt; &lt;/div&gt;    Adaptive: generate new renditions with quality settings for each breakpoint   Adaptive image is a service that is configured with a system set fixed-list of rendition widths that can be used for image sizing. Authors either can accept the default list of mapping or specify a custom list based on system configurations.      The template contains a list of all media queries and link to the asset with predefined selectors that trigger a service.   &lt;div itemscope=\"\" itemtype=\"http://schema.org/ImageObject\" component=\"true\" data-layer-componentpath=\"article/par/contentblock19/par/image\" class=\"image imageTitleDescription\" role=\"banner\" id=\"image19\" data-layer-track=\"false\" data-asset-id=\"4a0c05b8-10af-439a-8e04-c56386d9618d\" data-asset-trackable=\"true\" data-asset-licensed=\"false\" data-analytics-event-label=\"Asset Title\" data-analytics-metatype=\"image/jpeg\" data-analytics-filename=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg\"&gt;    &lt;figure&gt;       &lt;picture&gt;          &lt;!--[if IE 9]&gt;&lt;video style=\"display: none;\"&gt;&lt;![endif]--&gt;          &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.480.jpg\"                  media=\"(min-width: 1px) and (max-width: 533px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.640.jpg\"                  media=\"(min-width: 534px) and (max-width: 691px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.720.jpg\"                  media=\"(min-width: 692px) and (max-width: 770px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.800.jpg\"                  media=\"(min-width: 771px) and (max-width: 848px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.960.jpg\"                  media=\"(min-width: 849px) and (max-width: 1008px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.1024.jpg\"                  media=\"(min-width: 1009px) and (max-width: 1075px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.1280.jpg\"                  media=\"(min-width: 1076px) and (max-width: 1331px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.1440.jpg\"                  media=\"(min-width: 1332px) and (max-width: 1572px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.1920.jpg\"                  media=\"(min-width: 1573px) and (max-width: 1971px)\"&gt;             &lt;source srcset=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.2048.jpg\"                  media=\"(min-width: 1971px)\"&gt;             &lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;             &lt;img itemprop=\"contentUrl\"                  src=\"/content/dam/aemdesign-showcase/en/components/media/image/city2.jpg.img.2048.jpg\"                  alt=\"Asset Headline\" title=\"Asset Title\"&gt;       &lt;/picture&gt;       &lt;figcaption&gt;          &lt;h4&gt;Asset Title&lt;/h4&gt;       &lt;/figcaption&gt;       &lt;div class=\"description\" itemprop=\"description\"&gt;Asset Description&lt;/div&gt;    &lt;/figure&gt; &lt;/div&gt;    Rendition: pick suitable image rendition   Some scenarios require the selection of a specific rendition based on a set width of and asset.      This template only contains the image that was matched based on the specified width.   &lt;div itemscope=\"\" itemtype=\"http://schema.org/ImageObject\"      component=\"true\" data-layer-componentpath=\"article/par/contentblock17/par/image\"      class=\"image\" role=\"banner\" id=\"image17\" data-layer-track=\"false\"      data-asset-id=\"5b1dc46d-858c-4b3a-b23b-5f8b6e0e6770\"      data-asset-trackable=\"true\" data-asset-licensed=\"false\"      data-analytics-event-label=\"city3.jpg\"      data-analytics-metatype=\"image/jpeg\"      data-analytics-filename=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg\"&gt;    &lt;img class=\"img-fluid \" itemprop=\"contentUrl\" src=\"/content/dam/aemdesign-showcase/en/components/media/image/city3.jpg/_jcr_content/renditions/cq5dam.thumbnail.319.319.png\" title=\"city3.jpg\"&gt; &lt;/div&gt;   We hope these image conventions will help you design a much more robust Design Language System that will ensure the author will fully leverage the power of AEM.   If you want to check out these image conventions in actions start by running AEM container, you can find how to get started here: docker-aem-bundle, once you have a docker container running head over to showcase to checkout Image Component.   Once again if you need help reach out to us, we will be happy to help.  ","categories": [],
        "tags": [],
        "url": "/manual/image-conventions/",
        "teaser": null
      },{
        "title": "Design Language System",
        "excerpt":"              On This Page     Introduction   Reference for Terms   Design Language System Table of Contents           Introduction   A design language system is a collection of design principles and components that unite product teams around a common visual language.           Design is the description of visual aesthetics that are inferred from Brand Guidelines.            Language is the common dictionary of terms that describe the design elements and design options that apply to components components                       Design Elements refers to general design conventions that can be applied across all components and govern general component behaviour                        Design Options refers to a subset of design conventions that apply to specific components                        System is the definition of components and their behaviour and their relations with Design and Language.       The DLS can be considered the source of truth for how elements look and behave.           Designers, developers and content authors can use the DLS to check if an element of design already exists.            Content authors can use the DLS for instructions on how to use certain design components.       Like a natural language, the DLS is supposed to grow over time as components are progressively added to it   Design Language systems are aimed to be a shared Language for understanding design, that transparently leads to understanding implementation. Following definitions are made to ensure discrete understanding terms that are used   Design Language is a vocabulary that is used to describe the design.   Design Language System is a reference implementation of a Design Language.   Reference for Terms      https://spectrum.adobe.com/   Design Language System Table of Contents   Here is a list of things that you would cover as you define your Design Language System.      Principles - The principles provide the overall direction and connect the brand and goals to the design system. The principles are the why of the design system exist.            Brand       Experience Vision       Design Principles           Guidelines - These guidelines describe how to bring to life aspects of the experience and design system through the use of the foundations and components. The guidelines are the **how **of the design system.            Experience Contexts       Accessibility                    Visual           Inclusive           International           Bi-directional                       Movement                    Interactions           Motion           Choreography           Animation                       Naming                    Tokens                       Getting Started                    For designers           For developers                           Foundations - The foundations are the global constructs that inform and are used to construct all the components. The foundations are what of the design system.            Branding       Colours       Typography       Fonts       Illustrations       Sounds       Iconography       Spacing       Visualisation                    Data           Charts                           Content            Voice and Tone       Vocabulary - Author related       Language       Grammar       Alternative Text       Photography       Icons                    Logos           Chevrons                       Internationalization           Patterns - Experiences            Layouts                    Grid           Dialogs           Popups/Popovers           Trays           Toast                       Messaging                    Error           Info           Warning                       Tour           Unique Experiences            Homepage       Article List                    Article                       About Page       Terms and Conditions           Components - Reference from AEM.Design - A component is a discrete part of the design system that can be used in multiple contexts throughout the ecosystem. Components can have nested components and can be grouped.            Content                    Content Fragment           Content Template           File Download Link           Embed Source           External           Link           Content Reference           Table           Rich Text           Tool Tip           Page Author           Page Date           Page Description           Page Tags           Page Title                       Details                    Contact Details           Event Details           Location Details           News Details           Page Details           Generic Details                       Layout                    Article           Aside           Breadcrumb           Columns           Content Block           Content Block Menu           Content Tabs           Footer           Header           Nav Bar                       Lists                    Asset List           Contact List           Event List           Lang Nav           List           List Nav           Location List           News List           Page List           Search Results List           Tag List           Nav List                       Media                    Audio           Image           Video                       Template                    One Column Page           Three Column Page           Two Column Page                          ","categories": [],
        "tags": [],
        "url": "/manual/dls/",
        "teaser": null
      },{
        "title": "The Journey begins...",
        "excerpt":"Over last few years we have done lots of great work. We have worked hard and learned even harder. We meet along the way and have stuck together working tirelessly to better each other.   We believe that great things are simple, complex in nature but simple in execution. It’s why we do things we do, make hard things look easy.   And to that notion we arrived at an idea to share what we have learned with people who are interested.   We believe that what we know so far will put you in a position that your starting point is not zero but a way ahead on the curve.   We tried to make complex patterns simplified for understanding so that you can start small but still grow large without full rebuilds.   Some of the content and concepts you may see unnecessary at the start of your journey but its something that will be harder to introduce once you are on your way so bear with it at the start.  ","categories": ["blog"],
        "tags": ["journey","start"],
        "url": "/blog/2016/11/04/it-begins",
        "teaser": null
      },{
        "title": "Project Introduction",
        "excerpt":"The team has been busy do what they do best, creating something awesome!   It’s ready for release but it’s time to start a conversation around the project.   We have compiled a presentation for our sanity so that we can keep track of what we want to achieve and what is interesting to you.   Let me know what you think.       AEM.Design - Project Introduction  from Max Barrass  ","categories": ["blog"],
        "tags": ["project","update"],
        "url": "/blog/2017/04/06/project-introduction",
        "teaser": null
      },{
        "title": "Automation Testing and Human Reporting",
        "excerpt":"Automation Testing is the validation of your DevOps operations.   Without Automated Testing DevOps efforts can’t be verified. When writing automated pipelines some form of verification always takes place to verify service, api and general availability of targets before tasks are executed.   However a more systemic and pragmatic approach is required for verifying if your System works as you expect post Deployment pipeline.   It’s 2017 and testing tools have come a very long way, you can do so much these days with free tools it’s inexcusable not to use one or a combination of available frameworks.   Over last few days we have been refactoring our Test Suite to add some needed design to the reports. And after several late nights I am happy with the results.   We believe that Automation Testing has to be at the heart of you project. And what a better way to show off your Testing efforts by parading a nice-looking report!      And as you discover the wonderful world of Automation Test Reports, you realise that it has a much bigger business benefit then just a nod from UAT guy. You can and should use reports to your advantage and create test for everything you and your users use.   Another amazing feature that will save you lot and lot of time is to setup your report to test all common Breakpoints that your users would experience.   Here is an example of AEM Assets screen tested in Touch UI:      This is tested with Phantom JS so a few rendering issues do appear.   Here is AEM Project in XS view port:      Although majority of users not going to use these view ports the Multi-Viewport testing still should be carried out for all test as it does not create any overhead to testing effort.   Here is a few more examples of a login page, first in XS view port:    and in MD viewport:      Another very simple yet powerful feature used in automation testing is screenshot diff.   The process is very simple you create a master image of your expected outcome for a particular screen and you call that a reference master that corresponds to a particular test case. Then whenever you run same test case you take another screenshot and compare it with the reference master.      Usually if a difference is within 10% then the test considered as ok, but you can go lower if you want pixel perfect output.   We hope this will inspire you to try this yourself!   If you want to try this at home take a look Geb framework, it will save you a lot of time and together with Behaviour Driven Development practice you will always find time to test your experiences!   As always let us know what you think.  ","categories": ["blog"],
        "tags": ["testing","update"],
        "url": "/blog/2017/06/28/automation-testing",
        "teaser": null
      },{
        "title": "DevOps Automation",
        "excerpt":"Over last few weeks we have spent considerable time to get the DevOps bootstrap working more consistently across Mac, Linux and Windows.      Out of all of the operating systems Windows was the hardest and easiest to get working! Yes, it can be like that!   In the hindsight Windows it’s the easiest as you do not have a lot of choice for proper bash that can interact with Windows Processes directly, so and Cygwin handles this very well. In addition to this some corporates have Dual Account setup for all developers that requires developers to login as Local Admin account to install software. This is was challenging to play with and we would recommend to avoid as much as possible but in the end it work.      Mac on the other hand poses sever other challenges it comes bundles with Python so a use of private virtual environments for isolating from system installation was implemented and used across all OS’s.      Linux Ubuntu on the other hand was the simplest to setup and use, even if you have Secure Boot enabled only VirtualBox installation had extra steps to install signed driver.      Also during this update autocomplete was added to DevOps bootstrap!      As always let us know what you think.  ","categories": ["blog"],
        "tags": ["devops","update"],
        "url": "/blog/2017/07/04/devops-automation",
        "teaser": null
      },{
        "title": "Touch UI Migration",
        "excerpt":"It’s always great to head into the end of the year with a good milestone.   Last week migration to Touch UI has been completed!   You can now manage all of the template and create new templates with ease using OOTB template authoring tool available in AEM 6.3+!      As usual content containers have been upgraded lo allow switching from Responsive Grid to Parsys as you need.      All Showcase pages has been updated to ensure that new components can be used and tested.      Including all dialogs for all components that have Classic Dialogs now have TouchUI dialogs as well.      As always all dialogs have the common configuration features that allow complete control of styling for all components.   This has been a great outcome which was long coming and its further complimented by awesome features in AEM TouchUI!   Looking forward to testing further in AEM 6.4 Beta!!  ","categories": ["blog"],
        "tags": ["devops","update"],
        "url": "/blog/2017/12/06/touch-ui-migration",
        "teaser": null
      },{
        "title": "Touch UI Test",
        "excerpt":"End of the Year is a few days away!   It’s was great feeling to bring the Touch UI Migration so close to the end of the year!   But it’s almost as exciting as completing the Touch UI Testing of exact same components that just have been migrated!      Testing utils and all Specs have been migrated from Classic UI to TouchUI.   Additionally PhantomJS has been depreciated in favor of Headless Chrome!!   As you all know development of PhantomJS has been abandoned in favour of Chrome Headless. This comes as a welcome move as lots of latest JS and CSS features where hard to test using PhantomJS.   This is another awesome milestone to be carried as a great base for upcoming projects in 2018!   Happy New Year to all!!! See you all next year!!!   PS. Look forward to our JECIS integration coming early next year!!! We are going to use JECIS Framework to deliver eCommerce capability blueprint to your projects!!!  ","categories": ["blog"],
        "tags": ["testing","update"],
        "url": "/blog/2017/12/29/touch-ui-test",
        "teaser": null
      },{
        "title": "Touch UI Test",
        "excerpt":"2018 was just! It came and went!   So 1 Year on on since what has changed:     upgrade to AEM 6.4 was transparent without any side-effects   “so many repos” are now 4 and parent! This means quicker releases, everything has been compacted along functional need   its all about automation testing, selenium hub grid is used for local and pipeline builds   refactoring, refactoring, refactoring shredding all the old and adding cleaner ways of doing things   create a simple way to allow authors to select renditions per media query (view port / breakpoint) on components   integrated analytics DataLayer industry standard into templates   create new way of creating tag content when translating CSS into authors language   created a new prototype that uses (https://patternlab.io)[https://patternlab.io] as a base to demo your cool work   released all of the docker containers to Docker Hub (https://hub.docker.com/u/aemdesign/)[https://hub.docker.com/u/aemdesign/] with pipelines straight from gitlab   created tenant archetype that allow quickstart for tenants projects, that has tenant naming thought out including component groups and has all the tests ready to go   updated playbooks and deployment scripts   reconfigured version for pom files to be automated   refactored and and added new components and added more automation tests  ","categories": ["blog"],
        "tags": ["update"],
        "url": "/blog/2019/01/01/2018-came-and-went",
        "teaser": null
      },{
        "title": "Simple to Understand Easy to To Follow",
        "excerpt":"One of the biggest challenges when creating frameworks is to drive a convention that can be easily used by those who will use it.  AEM is not exception, being Java based its open for interpretation and development in many ways that fit the bill, which is the beauty of software development. This does make creating frameworks a challenge as you are constantly need to evaluate and refactor any deviation to your conventions.   When it comes to it refactoring of codebase comes in flavours of accepting the change and rejecting the change. Interestingly any choice you make has impacts that are hard to understand at the time and usually manifest in the long term.      Rejecting changes means that you stand a good chance of no one using your conventions.   Accepting any changes without consideration will result in a spaghetti monster.   There is no one answer to make it all work like as its complicated to solve and predict. But it does mean that conventions should be created and followed and improved over time. Having people on your project that understand conventions and have experience doing this does help, but this is possible by every one who strives towards it. Less experience leads to con   Having generalised conventions that apply across technology changes should be your aim. In practice these should be derived over time by evaluating the implemented technologies and conventions that they bring. Throughout refactoring efforts the conventions and patters will eagerly present themselves. Once a pattern appears repeatable it should be generalised so that its better understood.   Having a pattern or a set of patterns that apply in general across your project bring number of benefits:     it allow everyone on the team to achieve common understanding, having all team members speak the same language is essential   its easier to identify deviation from conventions that prompt change, without conventions comparing patterns will be a challenge   it enables a consistent experience for developers, ability to transition between projects without learning from scratch   it provides a simplified on-boarding process for new team members, it usually takes a while to on-board to a new project and it becomes harder if the project is a spaghetti monster   Over time reusable patterns on projects should be leveraged on new project to test their strength. Doing this allow you to evaluate and test your pattens in a new environment, new people and new set of requirements. This is a great method for improving your conventions and patterns. Most importantly by doing this it enables you to test if your pattern works.   Creating patterns should be about converting great ideas into simple pattern everyone can understand and easily follow without needing lessons in history.   ","categories": ["blog"],
        "tags": ["update"],
        "url": "/blog/2019/02/02/simple-to-understand-easy-to-follow",
        "teaser": null
      },{
        "title": "Migration from JSP to Sightly",
        "excerpt":"The time has come to migrate to Sightly. Primary drive is that Sling Models are great and Sightly now works (long story…).  Secondary drive is that it provides absolute templating without opportunity to embed code with template code.  Using JSP and JSTL work great, but it does not provide strict no “Code in Templates” governance. So if you are not careful you could end up with code plaguing your template and that would break your conventions. This has worked great over the years but as framework usage grows simpler oversight is required to ensure stability.   On the Sightly side the conventions is simple, Model has your code and your template has just the presentation. Sightly syntax docs are very easy to consume and anyone on this side of the keyboard can follow. Having pure JSTL implementation for your templates provides less opportunities to pollute your templates.   How to migrate your existing component to Sightly is not apparently clear.  Writing new component using Sightly in parallel with your existing component is not migration. Moving existing JSP component logic into Models is not a copy paste exercise, unless you have a solid convention across all component like AEM.Design. So the only sustainable option is to start a new project from scratch and use Sightly from the start.   Another way is to version your existing JSP components into V1 and create V2 for the Sighlty implementation. This is the approach we followed, this allow you to substitute all existing components with new Sightly verisons without having to migrate content.   Consider your existing component structure, when this component would be used in pages the reference to the component will be stored with each instance on component.   apps     aemdesign         component             text                 text.jsp                 .content.xml   Using this structure will effectively hardcode aemdesign/component/content/text into your pages and experience fragments. This creates a long term situation that when you want to update the component you need to update in place and in turn this updates all of the instances of your component everywhere it appears. This is the best approach as it ensure that you continue to update your component code and update content with latest version without adding unnecessary path version numbering into content. It best that versioning of component is kept to the component code and not hardcoded into content.   There could be rare scenarios when you may need to have a versioned path for a component but it would be hard to track of these paths over time. Additional authors will be exposed to versioned components where they will need to decide which version they need to use for a particular design they are creating. This would seem trivial but over time it will be affecting authoring experience due to number of component they need to understand to create designs.   Another approach elegant approach provides a simplified pattern to have versioning of component without exposing version to author and without hardcoding version into content. This pattern allow you to have one component path with localised versions that are not exposed to authors.   apps     aemdesign         component             text [ sling:resourceSuperType==aemdesign/component/content/text/v1/text ]                 .content.xml                 v1                     text                         .content.xml [ componentGroup=\"hidden\" ]                         text.jsp                 v2                     text                         .content.xml [ componentGroup=\"hidden\" ]                         text.html   To implement this pattern you create a sub folder for each version of your component as child of component. And point parent component path to the version you are currently want the authors to use. This pattern allow you to leverage version toggling without exposing versioned component to authors.   Furthermore AEM.Design framework uses this pattern to expose component into tenant applications. When you deploy AEM.Design core component you will have aemdesign application folder available to be used in a tenant component space.   apps     aemdesign         component             text [ sling:resourceSuperType==aemdesign/component/content/text/v1/text ] apps     tenant         component             text [ sling:resourceSuperType==aemdesign/component/content/text ]   This pattern combined with Variants and Badges provide number of benefits that     provide a way of component reuse across tenants without referencing core framework   ensures that tenant specific component paths are used in tenant code   allow customised metadata like title, description, category and readme’s for components where required   with use of badges and variants provides a way of extending component presentation without changing component core functionality   Considering the approach we took and the benefits that we have now attained make the migration successful! Further demonstrating to us that our determined efforts with AEM.Design principles can scale from “old” tech to new. And it is important to note that this was only possible due to the fact that we have had a strict component convention that allowed this process to occur. If design pattern were not maintained the rewrite of all component would have been the costly option.   ","categories": ["blog"],
        "tags": ["update"],
        "url": "/blog/2019/04/04/migration-from-jsp-to-sightly",
        "teaser": null
      },{
        "title": "Open source is for feedback",
        "excerpt":"Open source is at the core of AEM.   Supporting the community is the core principle of AEM.Design. AEM Design has always been about providing principled design patterns for AEM, that work in practice. Our components are tested through practice and implemented so that you can use them the way you want. We aim at developing a component that is free of noise and delivers exactly what you are looking for which is a clean, lean HTML footprint that speaks content and does not get on the way with opinions.   We strongly believe that open source provides the most transparent way of giving feedback about our work. We believe that having a common goal for creating and spreading good practices on making your AEM experience awesome. We do open source to encourage sharing of great things that can be done in AEM.   Here is the list of all components that we currently have in the framework. List source is located here Component List all components have been tested up to AEM 6.6 running in AEM SaaS.                  Component Category       Link                       Cloud Services / Rest       Rest                 Cloud Services / Salesforce API       Salesforce API                 Common / Redirection Notification       Redirection Notification                 Common / Static Content Include       Static Content Include                 Common / Timing Component       Timing Component                 Content / File Download Link       File Download Link                 Content / Embed Source       Embed Source                 Content / External       External                 Content / Link       Link                 Content / Content Reference       Content Reference                 Content / Table       Table                 Content / Rich Text       Rich Text                 Content / Tool Tip       Tool Tip                 Content / Page Author       Page Author                 Content / Page Date       Page Date                 Content / Page Description       Page Description                 Content / Page Tags       Page Tags                 Content / Page Title       Page Title                 Details / Contact Details       Contact Details                 Details / Event Details       Event Details                 Details / Location Details       Location Details                 Details / News Details       News Details                 Details / Page Details       Page Details                 Layout / Article       Article                 Layout / Aside       Aside                 Layout / Breadcrumb       Breadcrumb                 Layout / Columns       Columns                 Layout / Content Block       Content Block                 Layout / Content Block Lock       Content Block Lock                 Layout / Content Block Menu       Content Block Menu                 Layout / Content Tabs       Content Tabs                 Layout / Footer       Footer                 Layout / Header       Header                 Layout / Nav Bar       Nav Bar                 Layout / Container       Container                 Lists / Asset List       Asset List                 Lists / Contact List       Contact List                 Lists / Event List       Event List                 Lists / Lang Nav       Lang Nav                 Lists / List       List                 Lists / List Nav       List Nav                 Lists / Location List       Location List                 Lists / News List       News List                 Lists / Page List       Page List                 Lists / Search Results List       Search Results List                 Lists / Tag List       Tag List                 Lists / Nav List       Nav List                 Media / Audio       Audio                 Media / Image       Image                 Media / Video       Video                 Analytics / Analytics Data Layer       Analytics Data Layer                 Template / AEM.Design Base Page       AEM.Design Base Page                 Template / Cloud Config / AddThis       AddThis                 Template / Cloud Config / Google Analytics       Google Analytics                 Template / Cloud Config / Google Map       Google Map                 Template / Column / AEM.Design One Column Page       AEM.Design One Column Page                 Template / Column / AEM.Design Three Column Page       AEM.Design Three Column Page                 Template / Column / AEM.Design Two Column Page       AEM.Design Two Column Page                 Template / Common / Design Importer       Design Importer                 Template / Experience Fragment / AEM.Design Experience Fragment       AEM.Design Experience Fragment                 Widgets / AddThis / Addthis Button       Addthis Button                 Widgets / Online Media       Online Media                 Widgets / Search Box       Search Box                 Workflow / Content Fragment Page Generator       Content Fragment Page Generator                 Workflow / Process Payload       Process Payload                 Workflow / Project Task Manager       Project Task Manager                 Workflow / Project Update       Project Update                 Workflow / Rest       Rest                 Workflow / Salesforce API       Salesforce API                 Workflow / Send Email       Send Email                 Coral / Common/Form / Tag Field       Tag Field                 Coral / Datasources / Forms       Forms                 Coral / Datasources / Tags       Tags                 Coral / Foundation / Accordion       Accordion                 Coral / Widgets/Form / Asset Options       Asset Options           If you want to see these components in action, you can pull our latest docker container to get a quick preview of what comes out the box, view instructions here: Docker AEM Bundle  ","categories": ["blog"],
        "tags": ["update"],
        "url": "/blog/2019/06/05/open-source-is-for-feedback",
        "teaser": null
      },{
        "title": "Docker Containers Everywhere",
        "excerpt":"Docker is your best friend when it comes to AEM! Yes there are so many countless ways of running AEM instances. But AEM will always be better with Docker.  AEM in docker allows you to run multiple instances of AEM at a drop of a hat.  No need to copy files around or look for Jar’s.   If you want to quickly start a local demo AEM 6.5 instance on port 4502 with debug port 30303 all you have to do is run this command using aemdesign/aem image   docker run --name author \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4502:8080 -d \\ -p30303:58242 -d \\ aemdesign/aem     Don’t forget to have your AEM License key handy you gona need it for the AEM license page, and   Don’t forget the debug port you can use it in your IntelliJ Ultimate, you can read more about this here Run/Debug Configuration: JSR45 Compatible Server   Then you decide that you want to compare latest AEM to AEM 6.4 with a tweak to port 4512 and image tag aemdesign/aem:6.4.0 you are instantly in business   docker run --name author64 \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4512:8080 -d \\ -p30313:58242 -d \\ aemdesign/aem:6.4.0   Then if you decide to run AEM 6.5 publish instance, same command with minor update to AEM_RUNMODE to publish using same aemdesign/aem image and you have a clean publish starting up   docker run --name publish \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=publish,crx3,crx3tar,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4503:8080 -d \\ -p40404:58242 -d \\ aemdesign/aem   Wait there is more, if you like the sound and simplicity of AEM containers you gona love the aemdesign/dispatcher container!   Setting up Dispatcher is hard!  For one you have to know apache which is about 20 years old.  Then you need to know Dispatcher… which is also a tricky as it docs.. oh the docs.. you gona love trolling though them all to create your ultimate dispatcher config!   OR you run this to start your publish dispatcher pointing to your publish docker   docker run --name publish-dispatcher \\ -e APACHE_MODULES=\"/dispatcher/httpd/modules\" \\ -e APACHE_SSL_SUBJ=\"/C=AU/ST=VIC/L=Melbourne/O=AEM.Design/CN=dispatcher\" \\ -e APACHE_RUN_USER=\"apache\" \\ -e APACHE_RUN_GROUP=\"apache\" \\ -e APACHE_RUN_USERID=1100 \\ -e APACHE_RUN_GROUPID=1100 \\ -e APACHE_LOGLEVEL=\"debug\" \\ -e APACHE_VERSION=\"2.4\" \\ -e DISPATCHER_VERSION=\"4.3.2\" \\ -e DISPATCHER_LOGLEVEL=1 \\ -e DISPATCHER_CONFIG=\"author\" \\ -e DISPATCHER_NAME=\"dispatcher\" \\ -e DISPATCHER_PROPOGATESYNDPOST=0 \\ -e DISPATCHER_SERVESTALEONERROR=1 \\ -e DISPATCHER_STATLEVEL=3 \\ -e DISPATCHER_CACHEAUTHORIZED=0 \\ -e DISPATCHER_SESSIONMANAGEMENT=0 \\ -e RENDERER_HOST=\"$(route -n get 0.0.0.0 2&gt;/dev/null | awk '/interface: / {print $2}' | xargs ifconfig  | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | head -1)\" \\ -e RENDERER_PORT=4503 \\ -e RENDERER_TIMEOUT=10000 \\ -e RENDERER_RESOLVE=1 \\ -p 8080:8080 \\ -p 8433:8433 -d \\ aemdesign/dispatcher      Yes RENDERER_HOST does run an intimidating bash command to establish your local IP address 😎😻   You don’t need to access dispatcher container files to check the logs as they are all being redirected to container log, like all good container should!  In JSON format native to all your log monitoring tool! 😎😻 You can monitor logs with docker logs command   docker logs -tf publish-dispatcher --since=2019-07-16   This command will tail the error log from the container for you to see.  Change the parameter since to the date from wich you want to view the log from, log will get long, but that what log shipping is for 😎😻   Hope this will help you with your AEM Docker journey!   Have a look at our other handy docker containers at https://hub.docker.com/u/aemdesign  ","categories": ["blog"],
        "tags": ["devops","aem","docker","dispatcher"],
        "url": "/blog/2019/07/01/docker-containers-everywhere",
        "teaser": null
      },{
        "title": "Docker Automation Testing",
        "excerpt":"Quick update to showcase upcoming automated tests results using Github Pages.   On previous occasions the only way to show off how automation test suite result should look was to show some screenshots similar to this:           From now on the results will be published to github pages to provide an experience you should be having with your automate test suites.   You can view the output from test suite on github.   https://aem-design.github.io/aemdesign-aem-support/   Let us know what you think!  ","categories": ["blog"],
        "tags": ["devops","aem","docker","dispatcher","automation","testing"],
        "url": "/blog/2019/07/05/docker-automation-testing",
        "teaser": null
      },{
        "title": "Docker AEM Bundle",
        "excerpt":"Building on the previous work Docker Containers Everywhere we have added a new AEM 6.5 Bundle image.   Following is the package map to docker tag relationship, Docker tags conventions is {verison}-{bundle type}, bundle-forms includes all packages that are in bundle.                  File       Bundle Type                       AEM Service Pack       bundle                 AEM Forms       bundle-forms                 AEM Backward Compatibility package       bundle                 ACS Commons Twitter package       bundle                 ACS Commons Content       bundle                 ACS Commons All       bundle                 Netcentric ACL Tools       bundle                 Netcentric ACL Tools Oak Index       bundle                 Adobe Vanity URL Servlet       bundle                 AEM.Design Core       bundle                 AEM.Design Showcase       bundle                 Brightcove Integration       bundle                 Adobe XML Document Services       bundle           All packages are aimed at to be the latest version. If you need to know exact versions of a package, please refer to the pipeline for the version of the container you are using, example for AEM 6.5.3.0 Bundle with Forms https://github.com/aem-design/docker-aem/blob/6.5.3.0-bundle-forms/.github/workflows/build.yml   Existing Run Modes   Its recommended to use run-modes to specify different configurations for different target. AEM.Design Support project has a sub-module aemdesign-aem-config that contains reference configs for particular run-modes. Following is the definition of all run-modes, this should be expanded in your tenant codebase when you generate it for your project using archetype.                  Run Mode       Description                       config       default config for all instances                 config.author       author instance with specific author configs                 config.author.forms       author instance with Adobe Forms configs                 config.author.localdev       author instance for local development                 config.ldap       ldap config for all instances                 config.publish       publish instance with specific author configs                 config.publish.forms       publish instance with Adobe Forms configs                 config.publish.localdev       publish on local development           If you would like to provide environment specific configurations our recommendation would be to create individual repos for each configuration set, this will ensure that you do not mix prod and dev configs in one repo.   Running AEM in Docker   To start local author AEM 6.5 instance with SP3 instance on port 4502 with Bundled Packages run the following.   docker run --name author \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4502:8080 \\ -p30303:58242 -d \\ aemdesign/aem:6.5.3.0-bundle-forms   Starting local publish AEM 6.5 instance with SP3 on port 4503 is a matter of updating a run mode to publish and updating ports for accessing the service, and you should get the following.   docker run --name publish \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=publish,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4503:8080 \\ -p30304:58242 -d \\ aemdesign/aem:6.5.3.0-bundle-forms   If you would like to start AEM Bundle version on different port to say run it along existing aem instance all you need to do is change name of your container and its ports like this:   docker run --name author65bundle \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4565:8080 \\ -p30365:58242 -d \\ aemdesign/aem:6.5.3.0-bundle-forms   To start local demo AEM 6.4 instance on port 4502 with Bundled Packages run the following:   docker run --name author64 \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4502:8080 \\ -p30303:58242 -d \\ aemdesign/aem:6.4.0-bundle-forms   If you want to run a base AEM 6.4instance with Service Pack 8 on port 4502 run the following:   docker run --name author648 \\ -e \"TZ=Australia/Sydney\" \\ -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" \\ -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n\" \\ -p4502:8080 \\ -p30303:58242 -d \\ aemdesign/aem:6.4.8.0   You can checkout all of the available versions of AEM containers in Docker AEM Github repo.   License   You will need a license to activate the instance once it ready as it will prompt you to input your details on License splash screen before you can continue:      The confirmation screen will show you what version of AEM you are running.      Additionally, once you log in, you can visit the Product Info console to see AEM version. Your version number will be made up of major AEM version and Service Pack Version. For example, if you choose AEM 6.5 with Service Pack 1 its version will be 6.5.1.0.   Packages   You will notice that your bundle container will come with the latest SP installed and other packages. Each bundle image tag has a corresponding branch in GitHub you can check the .travis.yml file to see which packages are pre-installed.   Thank you   Please checkout the docker hub aemdesign/aem for further details.   If you would like to contribute or fork the code, you can get it on GitHub https://github.com/aem-design/aem.   Bundle version comes with following AEM.Design projects:      aemdesign-aem-core that contains all of the components code   aemdesign-aem-support that contains all of the supporting content, front-end code and component showcase.  ","categories": ["blog"],
        "tags": ["devops","aem","docker","automation"],
        "url": "/blog/2019/08/30/docker-aem-bundle",
        "teaser": null
      },{
        "title": "AEM and Docker 😍😘",
        "excerpt":"By now you would have seen previous posts Docker Containers Everywhere and Docker AEM Bundle. You might have tried out those images, if you have not, I encourage you to try them out, you will like it.   Now that you have tried those images out, one major question you may ask “is that for development only?”.   You might even think/say “I thought AEM does not work in Docker”?!   And the answer to both of those questions is no. You should be using Docker in production, if you are not you are missing out.   Docker is awesome, period. It once and for all creates a method for establishing consistency with pure simplicity. One of Docker best practices is to have one process per container, many great reasons why but not going to go into them, which is what AEM and mainly java does not play along with easily and we will return to this in a moment.   As far as AEM is concerned the issues that you might experience running AEM in a container comes from underlying Java Forking. Googling this will give more technical details but at high level this means that Java main process creates new process that are not “children” on the main process.   So AEM runs on Java and it forks. In AEM most obvious things that trigger this are workflows that execute external processes, external services that AEM hosts like image service and repository services that handle all of the content wiring and reading, sounds important right. So if we can solve this forking thing then the issue will go away.   This manifest a problem of running AEM in a container creates following situation:      you start a docker container   docker container starts and binds to main java process            any of its subsequent children processes are not managed by container           you try to stop the container docker will send a shutdown signal to container            that will pass that to the java process                    that java process will then respect that signal and gracefully close things it controls                            but will leave a bunch of processes orphaned 😞                                               docker container becomes unresponsive/hangs           you try to docker kill the container and all its internal orphaned processes            one of which will be the repository so you will lose content 😱 no happy ending here           Ok so yeah not so cool!   But what is cool is a project tini by Thomas Orozco that provides A tiny but valid init for containers. This solves the forking issue once and for all.   Adding tini as the entry point into your docker containers allows consistency in handling processes in that container.   This is how the implementation in a base container centos-tini looks like.   FROM       centos:latest  MAINTAINER devops &lt;devops@aem.design&gt;  LABEL   os=\"centos\" \\         container.description=\"centos with tini\" \\         version=\"0.18.0\" \\         imagename=\"centos-tini\"   ARG TINI_VERSION=\"v0.18.0\" ARG TINI_KEY=\"595E85A6B1B4779EA4DAAEC70B588DFF0527A9B7\" ARG TINI_URL=\"https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini-static-amd64\"  RUN curl -fsSL ${TINI_URL} -o /bin/tini &amp;&amp; curl -fsSL ${TINI_URL}.asc -o /bin/tini.asc &amp;&amp; gpg --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys ${TINI_KEY} &amp;&amp; gpg --verify /bin/tini.asc &amp;&amp; chmod +x /bin/tini  ENTRYPOINT [\"/bin/tini\", \"--\"]   Very simple image with key line ENTRYPOINT [\"/bin/tini\", \"--\"] that ensures that all container commands will be handled by tini. So this means that anytime a process is spawned in the container it will be a child of tini. So when it comes to closing the container tini will close all processes and thus you will have a graceful container stoppage.   Further reviewing the image for aem you will find similar ENTRYPOINT [\"/bin/tini\", \"--\", \"/aem/run-tini.sh\"] that uses an adopted script to run command exec java $AEM_JVM_OPTS $AEM_RUNMODE -jar $AEM_JARFILE $AEM_START_OPTS to stat the AEM java process. This ensure that the execute command is passed to tini for handling.   You can also use the CMD [\"/dispatcher/start.sh\"] as used in dispatcher image to the same effect. Docker appends the CMD statement to ENTRYPOINT command and as dispatcher is based on centos-tini its final command that will be executed will be [\"/bin/tini\", \"--\", \"/dispatcher/start.sh\"], once again letting tini manage processes.   Hopefully if you were scared of using java in docker containers after using tini your fears will wash away with tears of happiness 😂   ","categories": ["blog"],
        "tags": ["devops","aem","docker","automation","tini"],
        "url": "/blog/2019/09/04/aem-and-docker%F0%9F%98%8D%F0%9F%98%98",
        "teaser": null
      },{
        "title": "Updating Existing Docker Container Variables 💪😎👍",
        "excerpt":"Updating docker config of an existing container can be a daunting task. Usually its just easier to kill the container and start from scratch and this approach is preferred when it comes to docker principles.   As of current 19+ version of docker there isn’t a way to do it via API, this mean that you need to manually change config of container in the docker engine running your container.   Flow on effect is that when you change this docker config you will need to restart docker engine, which is fine when you have only one container running but if you have lots this is out of the question.   But lets say you have just started AEM instance not using the AEM Bundle container, without mounting any volumes and you have spent last hour installing packages and doing thing to that container that you do not want to do again. And you got an urge to do some java code debugging on your new container and you just realised that you did not add the required debug JAVA_OPTS when you started the container:    -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n   Starting from scratch will be good option by using the AEM Bundle by all those changes you made will be lost. At this point in despair you forget what paths you updated and you decide to persevere with updating docker engine config.   You can follow these steps to update your existing container config with java options that will allow you to debug your AEM instance in a container:      Stop your container   docker stop author      Edit config of your container   Running following command will load the docker config into VI and where you can proceed to update your container config:    docker run -it -v /var/lib/docker:/var/lib/docker alpine vi $(docker inspect --format='/var/lib/docker/containers/{{.Id}}/config.v2.json' author65bundle)    You will see config on one line, yes this is how it is and you need to thread carefully.   In our case you will need to scroll until you find  AEM_JVM_OPTS attribute scroll to the end its value and insert (press i to enter ) AEM Java Debug parameters:    -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n   Then press ESC key followed by :qw and press enter.   You now have your config tweak inserted and you can proceed.      Restart your docker   In worst case you can just reboot, in best case you can restart the service or use restart option of your Docker Desktop Menu:         Check your settings tweaks have worked   After your docker engine is backup you can check if your tweaks have worked   docker inspect author      Start your container   docker start author   This process can be used to update other settings as you wish.  ","categories": ["blog"],
        "tags": ["devops","aem","docker","automation"],
        "url": "/blog/2019/09/19/updating-existing-docker-container-variables%F0%9F%92%AA%F0%9F%98%8E%F0%9F%91%8D",
        "teaser": null
      },{
        "title": "Trigger Travis pipeline from another pipeline 👉📟🚀",
        "excerpt":"Keeping with DevOps spirit mean that things on you project should be very modular, this then will mean that you will have a lot of pipelines. Eventually you will come to scenario that will require pipelines to start other pipelines.   In our scenario whenever pipeline for aemdesign-aem-core succeeds its artifacts should be used in creating a docker container pipeline aem-design/aem.   Current Travis definition does not have OOTB option to do this. But fortunately travis comes with API that can be used to interrogate Travis config as well as trigger builds with API V3.   The process to trigger API is simple enough      Get a Travis API token from Travis Profile page, this is a manual step.   Send a POST request with specific headers to the API endpoint for your repo.   And that’s it really, all you need to do now is do the POST somehow.   As you come to expect, to make this as simple as possible for reuse in pipelines or manual execution, abstracting the API into a handy docker tavis-build-trigger image is easier done that writing about it.   The approach for docker container is to leverage NodeJS to make the request to API, abstract any logic into a nice package that can be executed anywhere where docker is available.   NPM has a very handy request module that makes accessing URI’s as easy as using curl.   Furthermore as the new tavis-build-trigger NodeJS app is a command line app, its mandatory to give optimal command line experience using yargs, after all, it’s little details that count. Yargs provides you with a very simple way of creating beautiful command line experiences without the arghh ( its a pirate-themed library).   When you execute the app though docker without any parameters   docker run --rm aemdesign/travis-trigger-build   You will be greeted with a nice command line helper menu in case you did not read the README to get you going with command line options.   Usage: travis-trigger-build.js &lt;command&gt; [options]  Commands:   travis-trigger-build.js start-branch-build                         Start repo build for a particular branch   [github_repo,travis_token,github_user]                                                                            [aliases: sbb]  Options:   --help, -h       show help                                                                                             [boolean]   --version, -v    show version                                                                                          [boolean]   --debug, -d      debug mode                                                                                            [boolean]   --github_repo    repo name                                                                                            [required]   --github_user    github user name where repo is located                                                               [required]   --travis_token   travis access token                                                                                  [required]   --github_branch  github branch to trigger build on                                                           [default: \"master\"]   --travis_url     travis url to use to trigger jobs                                  [default: \"https://api.travis-ci.org/repo/\"]  Examples:   node generator.js sbb --github_user=aem-design --github_repo=aem --github_token=&lt;TOKEN&gt;  Not enough non-option arguments: got 0, need at least 1 ________________________________________________________________________________   This provides a lot convenience and adds polish to your project. Having this library in docker container gets you away from having unnecessary scripts in your pipelines.   As always checkout the code, fork, extend and contribute if you wish.  ","categories": ["blog"],
        "tags": ["devops","aem","docker","automation","travis"],
        "url": "/blog/2019/10/01/trigger-travis-pipeline-from-another-pipeline%F0%9F%91%89%F0%9F%93%9F%F0%9F%9A%80",
        "teaser": null
      },{
        "title": "Enter the Github Actions 😘🐙🚀",
        "excerpt":"  CI/CD space if going off like a bunch of emoji in a url! But one thing you can be sure is to kiss 😘 your all-enveloping 🐙 pipeline tools good bye and put on your seat belt, as the pipeline mother-ship is taking off 🚀!   Travis, Gitlab, Jenkins, Azure DevOps, CircleCI, Codeship all of these and more are awesome pipeline tools! We use them daily, they do us proud of things that we can accomplish with effort alone in this virtual world of ours. They make us happy when we move our piplines from one provider to another by giving us latest YAML syntax. They make us happy when they give us badges that we wear with pride in our readme’s! They give us fancy plugins and cli tools that make us rewrite all of our pipelines over and over!   But late night wrestling with CI tools does leave feelings of doubt deep in your mind, maybe this is not the end game. Yes pulling data across the oceans so that you can just build the code does seem ok and mirroring your repos to another build system so that your Git LFS quota does not get smashed is worthy battle. But you wonder should you need to do all that and is there a better way.   We know that big things come from little things, so all the small battles with these awesome tools seem to be a built up to something big. All these battles helped us to figure out what we really need from these pipeline tools.   And it seems that the ask is much firmer now after all the experimenting and it goes something like this:      I want my code to be in a place where everyone can get at it.   I want my code base to be respected by everyone   I want my pipeline to be right there with the code so that I dont need to worry about any smudges, submodules and other solvable unknowns.   I want this YAML config to be easy to understand and simple to follow, like Travis but with more YAML   Sure there is things to consider but for lets see where this takes us.   Now to be clear Travis is #1 until you need to run something longer than 50min then is Azure DevOps at #2. Travis is simple and it give you exactly what you want and for free. Azure DevOps is the all in one package that you dream of, but you need to move your code from Github. 🤔   Gitlab is awesome for a few years we have been running on it, running over quotas etc pain full but worth while experience right up to archiving all project and moving to github. Gitlab is a great one-stop-shop if you want to run on-prem, as there is Github and Azure in paid categories, that compete at different level.   Github has become the defacto standard for open source projects. Yes Azure has tried to capture the market and its done a bloody great job and Gihub is now owned by Mirosoft, and we will see who will win the internal pageant in the end but there will always be open source favorite.   But all of this really does not really matter for now, what matters is that Github announced and delivered on their promise to have pipelines built into their offering. This was a long throw of a spanner and it has been is slow motion for a year, but it landed and pressed the tak off button! And its looking good! Yes there are features missing, but it wont be long.   Amazingly it seems that they copied some of the Azure DevOps pipeline components and have improved on them! This makes Github an absolute steal for open source project as its now one stop shop for all of your needs. It’s astonishing how much value this offers it leaves you with the thought what is the catch?! There aint none atm and I do hope they wont do Larry Ellison on us in a few years. Obviously people will just move to where there is more common sense.   For now we have started to migrate all of our pipelines from Travis to Github Actions, so far it has been a very quick migration there are many guides how to migrate but if you know your pipelines its simpler to just get started!   From Travis to Github Actions - the non definitive guide   To get started all you need to do is make .github/workflows/main.yml file in your project with following content:    name: CI  on: [push]  jobs:   build:     env:       GLOBAL_VAR: i am global       SECRET_VAR: ${{ secrets.SECRET_VAR }}     # set this in Github Repo -&gt; Setting -&gt; Secrets     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@v1       - name: run a one-line script         run: echo Hello, world!       - name: Run a multi-line script         run: |           echo Add other actions to build,           echo test, and deploy your project.       - name: run a one-line script with if         if: github.ref == 'refs/heads/master'         run: echo Hello, world!       - name: set step output and set some vars         id: stepwithoutputs         run: |           echo ::set-env name=COOL_OUTPUT::HELLO THERE ENV           echo ::set-output name=COOL_OUTPUT::HELLO THERE OUTPUT       - name: dump some vars         run: |           echo STEP_OUTPUT_MAP=${STEP_OUTPUT_MAP}           echo STEP_OUTPUT=${STEP_OUTPUT}           echo STEP_SET_ENV_VAR=${STEP_SET_ENV_VAR}           echo JOB_VAR=${JOB_VAR}         env:           STEP_OUTPUT_MAP: ${{ toJson(steps.stepwithoutputs.outputs) }}           STEP_OUTPUT: ${{ steps.stepwithoutputs.outputs.COOL_OUTPUT }}           STEP_SET_ENV_VAR: ${{ env.COOL_OUTPUT }}           JOB_VAR: ${{ env.SECRET_VAR }}       - uses: meeDamian/github-release@1.0         with:           token: ${{ secrets.GITHUB_TOKEN }}           tag: ${{ env.GITHUB_TAG }}           name: ${{ env.GITHUB_TAG }}           body: ${{ env.GIT_RELEASE_NOTES }}    Here you can see common items that you could use in your simple pipeline, its a good start for converting your pipelines.   Then you can go ahead and replace steps with the ones you have in your travis file. Here are some how to notes on things that you will need to know:      name: at the top is the ID of action so keep that short.   unlike Travis there is jobs/&lt;job_id&gt; layout where you can separate your flow if you need, initially having everything in one job is easiest, you can refactor once you have more requirements.   uses mean using another pre made action from marketplace, you pass parameters to actions using with.   you can use bash variables in run steps but you need to use “Context Expression” when doing it on other YAML attributes such if, when or passing variables to things.   if is added directly to step YAML and you use Context Expressions to evaluate your logic, ex check if current branch is master: if: github.ref == 'refs/heads/master'.   to export a variable to environment you need to do following echo command format echo ::set-env name={name}::{value}.   you can also set step outputs ::set-output name={name}::{value} that allow you to reference this step it in Context Expression steps.&lt;step_id&gt;.outputs.&lt;variable&gt; this separates global from step variables.   to use env variables in run steps you can just do ${DOCKER_REGISTRY} this will evaluate the variable as bash variable.   to use env in YAML parts such as with etc you need to use Content Expressions $ this will evaluate the variable as bash variable.   to pass secrets to steps or use them in env variables use the Content Expression $.   check Awesome List of Must Have Actions in your Pipeline](https://github.com/sdras/awesome-actions) for custom actions that will replace comparable Travis actions, example meeDamian/github-release@1.0 replaces Travis deploy step.   caching is not there yet but will be available in November 2019.   you can use Build Matrix see Github Actions YAML Syntax for more info   Following is a list of resource you should use to learn about syntax before you stat googling.      YAML Syntax   Github Actions YAML Syntax   Setting Variables   Global Variables and Secrets   Context Expression and Global Context   Awesome List of Must Have Actions in your Pipeline - check this before googling   Github Actions Forum - search here before googling   For better comparison here is an actual Travis pipeline:    language: java  if: tag is blank  services:   - 'docker'  env:   global:     - PACKAGE_PATH=\"$(pwd)/packages\"  cache:   directories:     - $PACKAGE_PATH   before_install:   - \"source &lt;(curl -sL https://github.com/aem-design/aemdesign-docker/releases/latest/download/get_config.sh)\"   - echo GET PACKAGES   - echo $PACKAGE_PATH   - if [[ ! -d $PACKAGE_PATH ]]; then mkdir $PACKAGE_PATH; fi   - echo PACKAGES CONTENTS $PACKAGE_PATH   - ls -latr $PACKAGE_PATH   - echo DOWNLOAD PACKAGES INTO ${PACKAGE_PATH}   - ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://helpx.adobe.com/experience-manager/6-2/sites/developing/using/tough-day/_jcr_content/main-pars/download-section/download-1/file.res/toughday-6.1.jar\"   - ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://repo.adobe.com/nexus/content/repositories/releases/com/adobe/qe/toughday2/0.9.2/toughday2-0.9.2.jar\"   - ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://repo.adobe.com/nexus/content/repositories/releases/com/adobe/qe/toughday2/0.2.1/toughday2-0.2.1.jar\"   - ls -latr $PACKAGE_PATH   - \"source &lt;(curl -sL https://github.com/aem-design/aemdesign-docker/releases/latest/download/get_version.sh)\"   #build and test install:   - docker build --pull -t $IMAGE:$IMAGE_VERSION .   - export CONTAINER_COMMAND=\"docker run $IMAGE:$IMAGE_VERSION $TEST_COMMAND\"   - echo CONTAINER_COMMAND=$CONTAINER_COMMAND   - export CONTAINER_OUTPUT=$(eval $CONTAINER_COMMAND)   - echo CONTAINER_OUTPUT=$CONTAINER_OUTPUT   - if [[ ! ${CONTAINER_OUTPUT} =~ ${TEST_COMMAND_VERIFY} ]]; then travis_terminate 1; fi   - docker images  #test script:   - echo \"LOGIN TO HUB.DOCKER\"   - docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD   - echo \"PUSH HUB.DOCKER\"   - docker push $IMAGE:$IMAGE_VERSION   - if [[ $TRAVIS_BRANCH == \"master\" ]]; then docker tag $IMAGE:$IMAGE_VERSION $IMAGE:latest &amp;&amp; docker push $IMAGE:latest; fi   - echo \"UPDATE README IN HUB.DOCKER\"   - if [[ $TRAVIS_BRANCH == \"master\" ]]; then docker run --rm -v $(pwd):/data/ aemdesign/dockerhub-description \"$DOCKER_USERNAME\" \"$DOCKER_PASSWORD\" \"$IMAGE\"; fi  ## Get the project version before_deploy:   - if [[ $TRAVIS_BRANCH == \"master\" ]]; then git tag $TRAVIS_TAG; fi  ## Create release in GitHub deploy:   provider: releases   tag_name: $TRAVIS_TAG   name: $TRAVIS_TAG   target_commitish: $TRAVIS_COMMIT   api_key: $GITHUB_TOKEN   skip_cleanup: true   on:     branch: master    Its ported version looks very similar Gitub Actions:    name: build  on: [push]  jobs:   build:      runs-on: ubuntu-latest     env:       DOCKER_REGISTRY: docker.io       ORGANISATION_NAME: aemdesign       DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}       DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}     steps:       - uses: actions/checkout@v1       - name: set envirnment variables         id: config         run: |           echo GET PACKAGES           export PACKAGE_PATH=$(pwd)/packages           echo ::set-env name=PACKAGE_PATH::${PACKAGE_PATH}           source &lt;(curl -sL https://github.com/aem-design/aemdesign-docker/releases/latest/download/github_get_config.sh)           echo $PACKAGE_PATH           if [[ ! -d $PACKAGE_PATH ]]; then mkdir $PACKAGE_PATH; fi           echo PACKAGES CONTENTS $PACKAGE_PATH           ls -latr $PACKAGE_PATH           echo DOWNLOAD PACKAGES INTO ${PACKAGE_PATH}           ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://helpx.adobe.com/experience-manager/6-2/sites/developing/using/tough-day/_jcr_content/main-pars/download-section/download-1/file.res/toughday-6.1.jar\"           ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://repo.adobe.com/nexus/content/repositories/releases/com/adobe/qe/toughday2/0.9.2/toughday2-0.9.2.jar\"           ./scripts/download.sh \"$PACKAGE_PATH/\" \"-\" \"-\" \"https://repo.adobe.com/nexus/content/repositories/releases/com/adobe/qe/toughday2/0.2.1/toughday2-0.2.1.jar\"           ls -latr $PACKAGE_PATH           source &lt;(curl -sL https://github.com/aem-design/aemdesign-docker/releases/latest/download/github_get_version.sh)        - name: build and test docker image         run: |           docker build --pull -t $IMAGE:$IMAGE_VERSION .           source &lt;(curl -sL https://github.com/aem-design/aemdesign-docker/releases/latest/download/container_verify.sh)           (cd test &amp;&amp; ./run_tests.sh \"$IMAGE:$IMAGE_VERSION\")           docker images        - name: login to docker registry         run: echo \"${{ secrets.DOCKER_PASSWORD }}\" | docker login ${DOCKER_REGISTRY} -u \"${{ secrets.DOCKER_USERNAME }}\" --password-stdin        - name: push image version         run: docker push $IMAGE:$IMAGE_VERSION        - name: push latest image on master         if: github.ref == 'refs/heads/master'         run: |           docker tag $IMAGE:$IMAGE_VERSION $IMAGE:latest           docker push $IMAGE:latest        - name: update registry description with readme on master         if: github.ref == 'refs/heads/master'         run: |           docker run --rm -v $(pwd):/data/ aemdesign/dockerhub-description \"$DOCKER_USERNAME\" \"$DOCKER_PASSWORD\" \"$IMAGE\"        - uses: meeDamian/github-release@1.0         with:           token: ${{ secrets.GITHUB_TOKEN }}           tag: ${{ env.GITHUB_TAG }}           name: ${{ env.GITHUB_TAG }}           body: ${{ env.GIT_RELEASE_NOTES }}     Differences are almost minor and migration follow copy-paste approach for majority of pipeline which is ideal. That’s all there is to this migration all you have to do now is commit and head to the Actions console in your repo to see your build take off 🚀 as the next stop is the moon!   As always checkout the code, fork, extend and contribute if you wish.  ","categories": ["blog"],
        "tags": ["devops","aem","docker","automation","github","actions","github-actions"],
        "url": "/blog/2019/10/20/enter-the-github-actions%F0%9F%98%98%F0%9F%90%99%F0%9F%9A%80",
        "teaser": null
      },{
        "title": "AEM Framework for Multi-Tenant Environments.",
        "excerpt":"Introduction   AEM.Design is about identifying best practices and patterns that should be embedded and used a starting point for creating solutions for AEM. Our approach is to combine these best practices and patterns into the open-source framework that can accelerate projects and provide a pathway for sharing knowledge with the community in a consumable production-ready framework. A lot of articles detail individual knowledge fragments that at times useful on their own but do not provide a clear direction for end-use. We have tried to create a consolidated reference end-to-end approach with AEM.design framework and tools.   This initiative aims at collating best practices and patterns that are proven to be useful on projects. It aims to leverage best practices not only from AEM knowledge base but also leverage best of the best from Front End, Automation Testing, DevOps and another related enablement tech. The aim of this initiative to provide a framework that can fit into existing solution practices without mandating a particular process.   All of the code is located in GitHub, Docker Hub, SonarCloud and published to Maven central.   Best place to start with this framework is to try out the Docker Bundle that has the framework and demo of all of the components. You can find how to get started here: https://aem.design/blog/2019/08/30/docker-aem-bundle   Our archetype project is aimed to generate a new tenant project that has all of the components required to run the AEM implementation project. It including automation tests, site showcase, frontend code implementation and component overrides tailored to you tenant name and project.   If you have any questions on particular issues you can raise issues in GitHub for repos there are a few of them.   Creating and managing an environment for Multi-Tenants requires considerable upfront planning. Starting AEM project is easy, and you can feel a great sense of velocity early on. Although your initial velocity will make you feel comfortable, this might not last and avoid future pitfalls is hard once you have released to production. To avoid pitfalls of the future means that you will need to be aware of some of the pitfalls you might encounter upfront, and this is very hard to convey and predict.   To protect projects from encountering technical pitfalls in the future, it’s recommended to follow several product best practices. A sheer number of best practices and patterns is overwhelming, and it’s tough for new entrants to appreciate all of the suggested practices. We found that establishing a set of goals and principles early on helps to provide a project with a pathway to success.   Technical patterns are easily avoided by leveraging frameworks that seek to embed knowledge into a useful framework. Providing input into business processes is a more complicated endeavour due to the way the project can be executed. From our experience, teams need to aim to establish a common design language which is used to communicate requirements and create an efficient delivery process that builds trust in the tools being used. This requires having open dialogue at the start of the project to ensure everyone is on the same page and are willing to commit to trusting automation process.   Following sections outline some of the elements of knowledge that should be kept in mind when establishing a project for a single site or multi-tenant sites.   Business approach   Be very transparent with the whole team, and every person needs to understand that they will all be required to login into AEM and use it, PMs and steak holders included, after all, it’s their future digital platform. Everyone must learn the basic terminology of AEM and Design Language that will be used to describe requirements, this avoids confusion for everyone, and everyone should be encouraging peers to use correct language.      Select primary Business Analyst to run project knowledge transfer, this will be your primary conduit   The project team focus is primarily on Authoring Experience, as this what will enable authors to create the visual experiences they want   Create a common Design Language to ensure designers and BA’s lead the conversation of explaining how designs are authored in AEM, not in some other external concepts   Establish a religious training for all end-users of AEM   Create a showcase of you chosen components and walk everyone (including stakeholders) thought it, showcase must be used for functional tests, so it’s not a throwaway   Establish a common knowledge repository for sharing knowledge while AEM project is running, use Confluence as it’s most accessible, do not treat this knowledge base as a dumping ground of notes, treat it like a knowledge book for the future. This space is for people to see what you have built not read endless meeting notes, all admin related content should not be primary focus for the space   Establish a author training site that will be updated by Authors and BAs, this should be like any other tenant   Delay all modification to core Authoring Experience, use YAGNI banner especially if everyone is new to AEM   Component that appears in multiples experiences(pages) and show same data structure but different visual presentation are variant of same component.   Focus on identifying Unique Experiences and Unique components Variants that make up those Unique Experiences.   Ensure analytics is discussed as Definition of Ready for each component.   Focus on content taxonomies to ensure content structure can scale from the start in DAM, Content Fragments, Experience Fragments, Tags, Forms and Site Pages. Each site should be in its own tenant folder with additional contextual segmentation that   should apply for each type of content.   Site Content must always be in Region/Language structure with primary Country and Language as default, essentially your site must be multi languish compatible from the start.   Do not let Information Architecture dictate site Content Architecture   All legacy SEO ideas and practices (anything that does not talk about microdata in page and components) could be tested using Functional Automation Tests using the Build in AEM Hobes framework. Doing this will allows authors to test their content when they create it. If it can’t be automatically tested, it’s not a requirement; it’s 2020 excuses don’t apply so to drop that requirement if it can’t be tested.   Acceptance Criteria and Acceptance tests must be part of Definition of Ready for DEV   Automation testing is not optional, and it’s the only way to verify Definition of Ready.   Technology Approach   For single and Multi-Tenant Projects consider that each site is a “tenant” not a sling workspace tenant but more of a virtual tenant used to segregate content from each site. This addition provides a method for security policies to be applied as users create content, as well as provide a clean separation of content and application code is required, especially as you are working of a single component codebase.      Create a showcase with your chosen components which are maintained Developers throughout development and Testers when helping to test   Focus on Functional Automation Testing for all components with Authoring (does dialog work), Publishing (does it interact in publish) and Screenshot (does it look right) perspectives. Automation test suit is for the team not for selected few it does not have to be pretty is need to be quick to adopt and allow testing other web services, Selenium still works.   Leverage Docker containers to ensure you are running consistent versions of services across all environments and especially Developers desktops, see Operations/Docker project   Run AEM with Segment and Datastore separates from the start   Leverage external ESB tool for API dev, eg ApacheNifi, try not to write API’s in AEM, external API tools can template/translate requests into direct Sling API request.   Offload processing to Kubernetes container farm to leverage containers.   Use overlays for each component per each site, as you will be using multiple framework eventually, this will allow you so substitute/update components in the future.   Segregate content of each “tenant” into individual sites; this pattern also applies to a number of locations where content is created by authors   Ensure Pipelines for build and deploy are established as soon as git and repos are created.   Ensure dispatchers and present for Author and Publish instances   Ensure that Frontend code is package as a stand-alone package and Page Client Libs are used to include in Templates, see Support/Compose module.   Leverage VLT tool to export and backup content from prod and import into Development environments as required, packages don’t work for large content farms   Leverage Ansible to persists logic for environment configuration, see Operations/Deploy and Operations/Ansible-Roles project.   Ensure dispatcher config is in code and in a Docker container, see Docker-Dispatcher repo   Do not allow manual modification of services/servers via console etc follow Configuration as Code for all infrastructure and services, especially servers, preferably run Centos Atomic edition which will force Docker usage, see Operations/VM project for how to generate Centos Atomic VMs appliances.   Leverage Content Fragments for structured content, use templated component to present that content.   Leverage Experience Fragments for building reusable Page Sections.   Do not build footer and header as massive components, instead create experience fragments and add them to Site Root page and inherit it thought the tree.   Ensure Analytics content can be updated by authors   Use Data Layer spec to output analytics content in page header   Use Data Layer spec to manage all fields that will be output by components and use for analytics   Do not implement any components that use any inline javascript for Analytics, no matter what.   Ensure each component has a unique ID attribute   Ensure each component you output is easily distinguishable from other stuff AEM adds, AEM.Design uses Boolean attribute “component”   Use lists for re-using content for presentation, look at Generic Details and List components for reference, they provide dynamic field specific templating and expose of component content without dumping all of the content on the page. Hiding 48 out of 50 fields of a component content is poor design, output only content you need, see Component Variant and List Badge patterns.   Separate config into a separate package and use run-modes   Separate authoring experience updates into a separate package   Use ACS Commons tools and check them before you build new components.   When using components from frameworks consider the impact on authoring experience, different frameworks have different authoring possibilities, with some making Authoring very Front End heavy without enabling Authors.   This is a non-exhaustive list, but it should be a good start starting point.   As always, we welcome contributions this list, let us know by leaving a comment or better yet raise an issue in the repo.   Share this on your favourite network if you find this useful.  ","categories": ["blog"],
        "tags": ["devops","aem","docker","knowledge","sharing","multi-tenant","framework"],
        "url": "/blog/2020/01/12/aem-framework-for-multi-tenant-environments",
        "teaser": null
      },{
        "title": "AEM SaaS Hands On 😍🚀🔭",
        "excerpt":"              On This Page     Introduction   AEM SaaS Author Hand On           Environments       Pipeline           AEM SaaS Pipelines Breakdown           Validation       Build &amp; Unit Testing       Code Scanning       Build Images       Deploy to Dev           AEM SaaS Pipelines What’s missing           Git Peer Review Workflow       Automated Functional testing       No Git LFS       No Felix Console           Conclusion           Introduction   If Github Actions was entry into End Game, latest Adobe AEM SaaS offering is the outcome of an End Game in another dimension, where Adobe is the clear victor! This stealthy engineering masterpiece is a true example of how great experience can provide so much, that words can’t describe the feeling.   Adobes new offering it’s a true testament to engineering and a huge demonstration to all vendors in this space, on how to do things that make a difference. Not often you get your hands on a piece of SaaS software where you open the console and see something that takes your breath away. Your world is turned, and you whisper to yourself this can’t be true, it can’t be that easy.   Well folk, it is!   Latest offering from Adobe demonstrates their commitment on Experiences and not only for End Users but also for Developers.   This new offering is the Kubernetes powered, container infused, sling application building behemoth, breathing CI/CD life into your projects with ease!   You can find plenty post and materials about tech behind the platform, but this post is about the Experience! We want to see show off the new Cloud Manager experience. This post should provide you with inspiration to jump onto the CI/CD experience that Adobe have gifted upon us!   So, without any further ado let’s jump straight to it.   AEM SaaS Author Hand On   To start playing with your Cloud Manager experience you will need to access it thought your Adobe Experience portal, this will be provided for you by Adobe but for now you can follow our blog to get the insight and prepare you to roll-out your first project.   First off you need to login to Adobe Experience Platform, this will allow you not only to login into AEC using your Adobe account but also provides same access to all AEM instances in the Cloud Manager! Which is amazing and so on SSO trend of 2020! Login screen is similar to the all of the login screens Adobe has been slowly introducing in last few years.      You can still use shared local admin accounts (you get one you share with Adobe) but it’s not something you should do in AEC and at all, for many painful reasons.   Once you have logged in you will be redirected to the AEC dashboard.      When you click the Experience Manager icon you should see Cloud Manager card with Launch link.      Clicking Launch on Cloud Manager card will lead you at AEC Program Overview page.      This console is your command centre for your environments and associated pipelines. From here you can control your environments, download logs, create and action pipelines. From now on this is the engine of your project!      First thing you will notice is the large banner across the top, this is your production status panel, it will report to you how your Production pipeline is going.   Just under that you will see two sections Environments and Pipelines.   Environments   Environments section allow you to check status of your environments, update and create new environments, download environment logs, access new environments, all of the features readily available and tucked away in the ellipsis (...) revealing a simple menu with only but primary experiences you are looking for. Additionally, when you click the Details button in this section you will be taken to a details screen that will show you      Available Configuration is tied to your account and point allocated for environments. You will only be able to have environments that have been assigned to you by Adobe. Spinning up and tearing down of the environments is as simple as clicking a submenu item on the environment.   Pipeline   Pipeline section allow you to create, update and run pipelines and this is broken down into Production and Non-Production. Manage Git button shows you a dialog that points you to the Adobe Git repo you will need to use when committing code.   Although environments will be your initial focus it will very quickly switch to the Pipelines which you will spend most of your time watching. 😍   So, let’s deep dive on the pipeline and what we can decipher from it’s logs.   AEM SaaS Pipelines Breakdown   Adobe pipeline offer is simple, it provides a dream pipeline process where you start with Adobe hosted Git Repo and fork into Quality or Deploy pipeline process.   This is a simple methodology and it seem to work as it saves a bunch of time on a project. All the team need to do is just get their code into the repo and everything is done for them, that has not existed with this ease until now.      As you can tell from the image the pipeline is divided into following stages      Validation - initial verify of your repo?   Build &amp; Unit Testing - maven build and test   Code Scanning - SonarQube evaluation   Build Images - Docker and Sling app build process   Deploy to Dev - Docker release and package install   This is similar process for PROD but with extra testing and approval steps.   As you can see the Non-Prod Deploy pipeline breakdown is simple so now let’s look what is happening under covers, let’s talk about notable things that can be observed from the logs.   Validation  No logs available for this but “Your Pipeline has been verified against a set of sanity checks.” could mean a lot of things, but it runs very fast so guessing it’s aim is just to check you have a Git repo with valid pom.xml that could be compiled, that could be a good start.   This step takes about 5min to run from our tests.   Build &amp; Unit Testing   In “build_maven_build.log” you can see [BUILD] Running maven build command(s) line and judging by what happens after that simple mvn package command is used as it compiles, tests and packages all modules in you project.   This step runs for about 5min and it would depend on your package and test content. It’s not clear from the logs if the artifacts are cached at this step or after code scan.   Code Scanning   This is where magic is starting to come into play. First of you get a nice review summary screen that shows you what the damage of your latest code cram, and it’s cool way of summarising underlying tools!      In addition to this you get to see a CSV that shows you things that you need to fix.                  File Location       Line Number       Issue       Type       Severity       Effort       Rule       Tags                       design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/install is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/components/template/cloudconfig/addthisconnect/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/components/lists/searchlist/v2/searchlist/cq:dialog/content/items/layoutTab/items/column/items/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/global/dialog/touch/badge/content/items/badgeConfigTab/items/column/items/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/components/template/cloudconfig/googleanalytics/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/components/media/image/v2/image/cq:editConfig/cq:inplaceEditing/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem                 design.aem:aemdesign-aem-common:2.0.618       0       Node /apps/aemdesign/components/template/cloudconfig/googlemap/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users.       Bug       Major               ConfigAndInstallShouldOnlyContainOsgiNodes       aem           PS. this is the complete list of issues that we got for first deploy of AEM.Design to Adobe SaaS offering.   Just looking at this the reported Severity seems to be very opinionated and super conservative. Having a readme file in your /apps/aemdesign/install folder does not make it a Major defect, but this it probably just splitting hairs at this point and removing that file is trivial.   Errors such as /apps/aemdesign/components/template/cloudconfig/addthisconnect/config is an OSGi config or install path which contains non-OSGi-related children that will not be visible to non-administrative users. seem to fail the blank config node name rule and yes this is Major once again.   These trivial issues will get some great solution in time as this is a great process to put in place for all AEM project from the start. Many AEM project will benefit from establishing initial baseline and would provide a clear for quality path.   This step takes about 5min to run, this would depend on amount of code you throw at it.   Build Images   This phase is responsible for generating two brand new Docker images that has all of your new code embedded into it. First image will contain all of your project contents and second image will be a final merged version of your project with latest AEM base image.   Essentially process builds a custom CRX-Quickstart with your features(converted packages) embedded into it from the start, this does mean that you will not be able to download or delete the packages using CRX/DE and with added benefit of separating these code package from actual content in your repository.      The logs show standard Docker build process with bunch of parameters being passed to the Docker build process. Namely the build process relies on Packages that were built in previous steps these are passed as a URL list which are downloaded and converted to Sling Features using tool similar to sling-org-apache-sling-feature-cpconverter.   The process also creates a list of packages that are have content to be installed into repository, this list is used in deploy step.   All the packages once converted get store into src/main/features/generated-author with relevant JSON files describing features in src/main/features/generated/001_sew-aem-common.json. After this a maven build process is executed to compile your features into latest version (at the time of writing 6.6.0-V17414) of AEM Quickstart. Adobe has indicated that they are moving towards daily releases so this means that this process will pick up latest version of AEM when it’s available.   After this conversion and merger of AEM sling features, AEM image is started as container to initialise it’s segment store. Once the instance is initialising it’s stopped and Apache Jackrabbit Oak maintenance is executed, first checkpoint then compact. Once this is done both docker images are uploaded to Adobes Docker Image Repository. And this same process repeats for Publish images changing runmode=publish in the process.  At the end of this process which takes around 10-15 min to run you end up with Author and Publish images sizing at 4GB each.   Deploy to Dev   Deploy phase starts with downloading content packages that were isolated in previous phase. Followed by starting and waiting for Author instance, at which is tries to install downloaded packages into the instance and stop the instance on completion.   After this next process start the author and runs a bunch of bash scripts, that enable features, nodestore, blobstore, logging, set admin password validate and link license key. After this AEM is started once again and once ready is stopped and Oak Indexes are regenerated.   After this 10+ min step that instance is started again and marked as available for use, which is not recoded in logs and must be an extra step outside of the pipeline.   As you can see this is straight forward pipeline that just works. Lets discuss the obvious question that is at the top our mind right about now. What’s missing?   AEM SaaS Pipelines What’s missing   Well as this is hosted on AEM there will be a few CI/CD limitations. Limitations are good as they provide less distraction and an opportunity to improve. Here are the things that we find missing so far, they are not deal breakers but good to keep on the back of your mind.   Git Peer Review Workflow   Adobe Git is only a URL to which you push your code, these days all development should revolve around Pull Request Approval process. Covering benefits of this is not required as they are covered in great depth in many articles.   To enable this process to happen on your projects you will need to use external Git repo and manage code reviews there before you publish this final code into Adobe Git.   This is a small inconvenience and it’s readily fixed seeing as all companies these days have a form of Git and in cases where that’s not the case, GitHub, Bitbucket and Gitlab all support this process for free. Additionally, these tools have built in pipeline tools that will help you to push code to Adobe Git.   Automated Functional testing   Screenshot testing using Selenium or other testing tools is not in and you would need to cater for that yourselves. Most obvious reason for this as there is no one way of doing this and everyone does what they need for their situation.   Additionally, current Deploy pipelines are fixed to a specific flow which you cannot change. This means that in cases where you need to do automated functional testing you would need to do this using external pipeline.   Potentially you could just run your automation test tool of choice manually against a Dev instance in the Adobe environment. But in cases where you would like this to be automated you would have followed another approach.   One approach could be is to still have external Git repo and a pipeline that could build and test code and on success push it to Adobe Git for release to Dev cycle. This would be an ok mechanism as you could do this free on GitHub using containers see Exhibit 1 that runs in GitHub Actions pipeline. Plus, you would get PR ability.   No Git LFS   If you are using Git Lfs you going to need to revert to plain git as there is not Git Lfs in Adobe’s Git and you will end up publishing pointers to your images into AEM.   No Felix Console   There is no Felix Console, but there is a brand-new custom Developers Console that provides very limited tools that you might use.      Standard Felix console does have a lot of features and some can cause a few issues so it’s no surprise it’s not available and have been replaced with a tool that allows you download that for review.   Here are some of the available screens, Status screen will be your main go-to console to download content of some frequently used Felix console.                   12-developer-console-java-packages                    12-developer-console-queries                    12-developer-console-servlets                    12-developer-console-status-download-logs         Conclusion   As this is an Adobe’s work in progress and the masterpiece is not finished yet, it’s expected that new features will be added as adoption grows.   It will not take you long to get used to all the options and you will soon be longing for this simplicity in everything. Alternatives experiences to this are far more complicated and although they are fun to create, they can divert your attention and that you need not to do anymore!   From development perspective there are a lot of features that you will not see migrated which is a good thing, as Adobe’s engineers have a good handle on what is used and it’s usefulness beyond just being there part of a legacy.   So, we hope you have had just enough content to give you a quick overview and excite you to jump on board.   There is a whole array of documentation available at your favourite site in the Experience Manager Cloud Manager Help section, explore the new capability that is at your disposal and review official docs if you get stuck.   As always if you want more drop us a line, checkout the code and submit some issues if you find any.  ","categories": ["blog"],
        "tags": ["devops","aem","saas","knowledge","sharing","handson"],
        "url": "/blog/2020/02/01/aem-saas-hands-on%F0%9F%98%8D%F0%9F%9A%80%F0%9F%94%AD",
        "teaser": null
      },{
        "title": "AEM Magento Integration 😍🚀🔭",
        "excerpt":"Introduction   AEM when integrated with an eCommerce provider provides a great experience for online shopping functionalities.   eCommerce functionality is inherent in AEM which shows from demo sites like we retail. As AEM provides very perfect handling of content like authoring and publishing and managing assets, integrating it with eCommerce system provides a perfect way to build a robust eCommerce site.   AEM connects with eCommerce providers, Like SAP Commerce, Salesforce, Magento and more. AEM provides specific eCommerce frameworks to connect to eCommerce providers. In this blog we are going to see how AEM connects to Magento eCommerce. There are two ways to connect to an eCommerce provider Adobe IO or Commerce Integration Framework for a provider. Because AEM provides a Commerce Integration Framework connector to connect to Magento, we will be using that. CIF uses GraphQL queries to talk to Magento and bring data.   Note: To connect to eCommerce providers other than Magento we need to go through Adobe IO. For more info visit. : https://www.adobe.io/apis/experiencecloud/commerce-integration-framework/faq.html   Let’s jump into the steps to implement CIF now.   The commerce integration framework can be found at below locations. Adobe provides production ready components also which can be used.      AEM CIF components   AEM- CIF connector and authoring tools   Build the CIF connector framework or add in your dependencies. Once installed in AEM we can get option to configure the integration properties. Two configurations have to be done. GraphQL client configuration and CIF catalog Magento configuration.   Below are the steps where we have configured these.   CIF GraphQL Client Configuration Factory   Add GraphQL service – https://magento-hostname/graphql      CIF Catalog Magento GraphQL Configuration Factory     Once configured Test the connection in postman, using below query. Results depend on correct products configuration in Magento also.   { \tcategory(id: 2) { \t\tid, name, url_path, product_count, children_count, children { \t\t\tid, name, url_path, product_count, children_count, children { \t\t\t\tid, name, url_path, product_count, children_count, children { \t\t\t\t\tid, name, url_path, product_count, children_count, children { \t\t\t\t\t\tid, name, url_path, product_count, children_count \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t} }   The response must return results with exact numbers. A sample result is below   { \t\"data\": { \t\t\"category\": { \t\t\t\"id\": 2, \t\t\t\"name\": \"Default Category\", \t\t\t\"url_path\": null, \t\t\t\"product_count\": 7, \t\t\t\"children_count\": \"3\", \t\t\t\"children\": [{ \t\t\t\t\"id\": 5, \t\t\t\t\"name\": \"Mens\", \t\t\t\t\"url_path\": \"mens-shirts\", \t\t\t\t\"product_count\": 2, \t\t\t\t\"children_count\": \"1\", \t\t\t\t\"children\": [{ \t\t\t\t\t\"id\": 6, \t\t\t\t\t\"name\": \"Footwear\", \t\t\t\t\t\"url_path\": \"mens-shirts\\/footwear\", \t\t\t\t\t\"product_count\": 1, \t\t\t\t\t\"children_count\": \"0\", \t\t\t\t\t\"children\": [] \t\t\t\t}] \t\t\t}, { \t\t\t\t\"id\": 4, \t\t\t\t\"name\": \"SubCategory01\", \t\t\t\t\"url_path\": \"subcategory01\", \t\t\t\t\"product_count\": 2, \t\t\t\t\"children_count\": \"0\", \t\t\t\t\"children\": [] \t\t\t}] \t\t} \t} }   Now it’s time to create binding in AEM Commerce. This will fetch us the products from Magento to use anywhere or in commerce components.   Below image describes the binding configuration.    Once binding is successfully done, results can be seen in AEM ecommerce. The below image shows results in AEM ecommerce after successful binding with Magento.    Thank you.  ","categories": ["blog"],
        "tags": [],
        "url": "/blog/2020/03/06/aem-magento-integration%F0%9F%98%8D%F0%9F%9A%80%F0%9F%94%AD",
        "teaser": null
      },{
        "title": "Using Docker to Build Code",
        "excerpt":"When you have been working for a long time on a codebase, you don’t tend to test if your code can be compiled on other machines. Most of the time, it means that it won’t. But when you have Docker on your side, your dispair would be a one short docker command line deep.   Using Docker to build your code is so easy even your friend will think you are cool when you tell them about it.  The most amazing thing that you don’t even need to write any Docker images, there are so many ready-to-go buildpack containers out there you can easily pick up something that you need.   Here is an example of a container we use to do pipeline build and its very suitable for compiling your project on your local desktop. This container is a Centos 7 Jave Build Pack which means that it comes preconfigured with a majority of tools that are needed to compile our projects.   This container comes with Jave, NPM and RVM, and you can take a look at the contents of the dockerfile.   In power Shell:   docker run -it -v ${PWD}:/build/source -v ${HOME}/.m2:/build/.m2 --net=host aemdesign/centos-java-buildpack /bin/bash --login   In Bash:   docker run -it -v `pwd`:/build/source -v ${HOME}/.m2:/build/.m2 --net=host aemdesign/centos-java-buildpack /bin/bash --login   Let’s break this command down.      -it means run interactive terminal   -v ${PWD}:/build/source map current path into container at path /build/source            in Powershell ${PWD} is same as pwd in bash           -v ${HOME}/.m2:/build/.m2 map your Maven cache folder into the container to reuse your already downloaded jars   --net=host allow container to access your desktop localhost   amdesign/centos-java-buildpack image to use   /bin/bash --login run bash and perform login to ensure all of the start-up profile scripts are executed   All you need to do now is to run this command in the directory where you have your code and start compiling like a boss.   Don’t forget to tell your friends.  ","categories": ["blog"],
        "tags": ["devops","aem","docker"],
        "url": "/blog/2020/07/24/using-docker-to-build-code",
        "teaser": null
      },{
        "title": "Creating Custom Workflow Step",
        "excerpt":"When writing custom workflow services, you may find yourself not seeing your service being recognised by the Process Step. You will first encounter this when you don’t see your service appear in the process list on the dialog. And once you verify the data source that feeds that dropdown at http://localhost:4502/libs/cq/workflow/content/console/process.json you will wonder why. You may also see errors like this Could not find service for service reference {YOUR WORKFLOW STEP CLASS PATH} with label {no label} that could just tell you your class is missing property process.label.   Now that you know, you add this property to your class and your class appear in the list, here is an example of how to add it:   @Component(     immediate = true,     service = WorkflowProcess.class,     property = { \"process.label=Content Fragment Page Generator\" }     )   Also while debugging this, you may find some other errors polluting your docker logs.   The activate method has thrown an exception (java.lang.IllegalStateException: org.apache.sling.api.resource.LoginException: Cannot derive user name for bundle com.adobe.acs.acs-aem-commons-bundle [553] and sub service workflowpackagemanager-service   To fix this, all you need to do is add missing service mapping mentioned in the message. You should be able to replicate this by restarting your missing component at eg http://localhost:4502/system/console/components/design.aem.workflow.process.ContentFragmentPageGenerator. In example above missing use name is workflowpackagemanager-service and bundle is com.adobe.acs.acs-aem-commons-bundle. To add this missing entry do this:      open http://localhost:4502/system/console/configMgr/   search for com.adobe.acs.acs-aem-commons-bundle look for mapping in Apache Sling Service User Mapper Service Amendment   add or update blank entry with com.adobe.acs.acs-aem-commons-bundle:workflowpackagemanager-service=workflow-process-service   Hopefully, after this, your custom workflow step will work, if you are stuck, look at some examples in aemdesign-aem-services/../workflow/process.   Don’t forget to tell your friends.  ","categories": ["blog"],
        "tags": ["devops","aem","structure","bugs-maybe"],
        "url": "/blog/2021/01/18/creating-custom-workflow-step",
        "teaser": null
      },{
        "title": "Automation Testing For AEM Dialogs",
        "excerpt":"Automation testing is an absolute mandatory and covered in Automation Testing and Human Reporting and demonstrates a viable, usable AEM Automated Testing approach and does not make the automated testing suite a development only agenda.   Over the last few years, AEM Automation Testing for AEM Dialog has been getting more focus, and I have been asked by many how to do this easily. The current approach leverages existing AEM Editor experience to view and load dialogs so that they can be tested. One of the improvements that have been asked can that be made faster so that actual pages do not require loading, so that spec execution speed improves.   AEM being a gem of capabilities has this covered, and with little effort, we can leverage this to really create powerful specs that test component dialogues as a user would use them. The key to this is understanding how AEM loads component dialogs and the data they represent. Fortunately this pattern very simple using sling.      First you need a path to a dialog (/apps/aemdesign/components/details/generic-details/v1/generic-details/_cq_dialog.html) this path is a component that takes as a parameter as a path to the component dialog should show and update.   Second you need a content path (/content/aemdesign-showcase/au/en/component/details/generic-details/jcr:content/article/par/contentblock7/par/genericdetails) which dialog should update. This is simply any path that dialog will use for reading and wirting.   Third you combine these into a url you can use for automation http://localhost:4512/mnt/override/apps/aemdesign/components/details/generic-details/v1/generic-details/_cq_dialog.html/content/aemdesign-showcase/au/en/component/details/generic-details/jcr:content/article/par/contentblock7/par/genericdetails   And that’s it! Now you can write any tests around this URL. Taking this knowledge a spec can be updated to allow testing AEM Dialog with ease and without loading whole pages!   Here is a reference AEM component dialog spec that tests of the tabs that appear on the component have the right content appearing. This is done simply by taking a screenshot of the dialog’s page.   package specs.component.details.genericdetails  import spock.lang.Stepwise import support.AuthorDialogSpec  @Stepwise class GenericDetailsAuthorDialogSpec extends AuthorDialogSpec {      String pathPage = \"components/details\"     String pathSite = \"mnt/override/apps/aemdesign\"     String language = \"\"     String componentPath = \"generic-details/v1/generic-details/_cq_dialog\"     String pageExtensionSuffix = \"/content/aemdesign-showcase/au/en/component/details/generic-details/jcr:content/article/par/contentblock7/par/genericdetails\"      def setupSpec() {         loginAsAdmin()     }      def cleanupSpec() {         analyzeLog()     }      def \"Dialog of Component with Content\"() {          given: \"Component dialog exist\"         def selector = \"coral-dialog\"          when: \"I open dialog with content\"         go \"/${pathSite}/${pathPage}/${componentPath}${pageExtension}${pageExtensionSuffix}\"          then: \"The component dialog should render\"         waitFor { $(selector) }          and: \"Dialog should be able to open\"         showDialogDirect()         report(\"Dialog should be able to open\")          when: \"When I select Layout tab\"         selectDialogTab(\"Layout\")         waitFor { tabSelected(\"Layout\") }         report(\"Layout tab selected\")          then: \"Then it should have the Custom Layout options selected and matching configuration options\"         designRefFull(selector, \"tab-layout\")          where:         viewport &lt;&lt; getDialogViewPort()      } }   Once you run this spec you will get an excellent report that will help you determine if the dialog works as you expected it.      As you can see this pattern will allow you to test AEM Dialogs especially if you are into making customised controls, if you are stuck, look at some examples in GenericDetailsAuthorDialogSpec.groovy.   Don’t forget to tell your friends.  ","categories": ["blog"],
        "tags": ["devops","aem","testing","automation-testing"],
        "url": "/blog/2021/01/21/automation-testing-for-aem-dialogs",
        "teaser": null
      },{
        "title": "AEM SDK and JDK11",
        "excerpt":"Building on the previous work Docker Containers Everywhere, AEM and Docker 😍😘 and Docker AEM Bundle its time to bring AEM SDK and JDK11 into life!   If you take a look docker hub and docker-aem branches you will find a couple of new additions that you will find helpful.   JDK11 version of AEM 6.5 and AEM SDK version is now ready for use!   Running AEM JDK 11 in Docker   To start author AEM 6.5 with SP10 on JDK11 run the following:         docker run --name author655 -e \"TZ=Australia/Sydney\" -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n -XX:+UseParallelGC --add-opens=java.desktop/com.sun.imageio.plugins.jpeg=ALL-UNNAMED --add-opens=java.base/sun.net.www.protocol.jrt=ALL-UNNAMED --add-opens=java.naming/javax.naming.spi=ALL-UNNAMED --add-opens=java.xml/com.sun.org.apache.xerces.internal.dom=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/jdk.internal.loader=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED -Dnashorn.args=--no-deprecation-warning\" -p4502:8080 -p30303:58242 -d aemdesign/aem:6.5.10.0-jdk11   To start author AEM SDK version 2021.10.5958 run the following:         docker run --name authorsdk2021105958 -e \"TZ=Australia/Sydney\" -e \"AEM_RUNMODE=-Dsling.run.modes=author,crx3,crx3tar,forms,localdev\" -e \"AEM_JVM_OPTS=-server -Xms248m -Xmx1524m -XX:MaxDirectMemorySize=256M -XX:+CMSClassUnloadingEnabled -Djava.awt.headless=true -Dorg.apache.felix.http.host=0.0.0.0 -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=58242,suspend=n -XX:+UseParallelGC --add-opens=java.desktop/com.sun.imageio.plugins.jpeg=ALL-UNNAMED --add-opens=java.base/sun.net.www.protocol.jrt=ALL-UNNAMED --add-opens=java.naming/javax.naming.spi=ALL-UNNAMED --add-opens=java.xml/com.sun.org.apache.xerces.internal.dom=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/jdk.internal.loader=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED -Dnashorn.args=--no-deprecation-warning\" -p4502:8080 -p30303:58242 -d aemdesign/aem:sdk-2021.10.5958   To make all this possible following Docker image chain has been updated:      aemdesign/aem:jdk11 - AEM Quickstart content            aemdesign/aem-base:jdk11 - AEM linux dependencies                    aemdesign/java-ffmpeg:jdk11 - provides ImageMagic and FFMpeg libraries                            aemdesign/oracle-jdk:jdk11 - provides a an oracle jdk                                    aemdesign/centos-tini:centos8 - provides a base for all java apps                                                                                   In addition to these pipelines have been updated to allow Docker Image squash experimental option to ensure all images have the smallest amount of layers.   Additionally, centos build pack has been updated to JDK 11 and Centos 8 with all the swiss army knife tools one expects.      aemdesign/centos-java-buildpack:jdk11   Thank you   Please checkout the docker hub aemdesign/aem for further details.   If you would like to contribute or fork the code, you can get it on GitHub https://github.com/aem-design.   Don’t forget to tell your friends.  ","categories": ["blog"],
        "tags": ["devops","aem","docker"],
        "url": "/blog/2021/03/16/aem-sdk-jdk11",
        "teaser": null
      },{
        "title": "AEM Akamai Cache flush Agent 😍",
        "excerpt":"Introduction   After the first hit to the page in aem and HTML response received for first time from publish instance will get cached on Akamai level.   Subsequent request to the same page will be served from the cached content in Akamai rather than hitting dispatcher / publisher.   Anytime did you struggled to get the latest HTML from publisher instead of Akamai cache?   Well we did!!!   What we have done   We have worked on AEM replication agent for flushing Akamai cache whenever page gets published.   So, after author change a page content and publish it our Akamai cache flush agent configured on publisher environment will pick that page and request to akamai for clearing cache.  So that user of that page will get the latest content instead of cached old content from Akamai.   It is all automated, we don’t need to clear the Akamai cache when new product goes live to prod.   We don’t ask DevOps to clear Akamai cache so customers will see latest page. Lets save their 1-2 min(s) time whenever new product launch.   Where you can find the code   Akamai Cache Flush Agent   Akamai Transport Handler   What are all details do you need to setup flush agent      akamaiDomain   akamaiBaseUrl   akamaiPurgeUrlPath   clientToken   clientAccessToken   clientSecret   If you think you don’t know these info’s or not sure from where you can get it? Ask devOps these information and say I got your back if you provide me these info 😍   How we are managing the secrets   After getting the above information from you, we are encrypting keys using AEM’s crypto support and storing it on AEM so you are safe with your secrets. While we use it for making the POST call from Transport Handler we will decrypt the keys and use it.   Also while making a POST call to Akamai servers we are using HMAC_SHA_256 to protect the data.   Make sure you are configuring the Akamai cache flush agent on each environment separately   How to configure Akamai flush agent on your AEM author / publish instance   By Assuming you have installed aem design code into your local AEM.   When to setup on author and when to setup on publish   Setup Akamai flush agent on AEM author instance only if you have akamai setup on author level as well. Mostly we will have Akamai setup for publish env.   Always setup Akamai flush agent on publish level so as soon as the page reaches publish instance our Akamai flush agent will go ahead and clear Akamai Cache.   How to setup Akamai flush agent   Go to miscadmin and open replication/agents.author for author instance &amp; replication/agents.publish for publish instance   here I’m showing example of setting flush agent in author level same time you can set it in publisher as well.      Click new from tool bar and you will see the Create Page dialog.      Select “Akamai Publishing Replication” and give your replication agent a name &amp; title. Click on create and open the newly created agent on the list. (it will be the last entry on the list) Click on Edit and provide the information required and click on Ok.         You should be able to see the Akamai Flush Agent is On (green) and it will look for any replication events.      Click on Test Connection link and make sure you have all the correct configurations. You should see “Replication test succeeded”   Conclusion   This component will save our time whenever we need to update the content in AEM pages.   Make sure you have set up the dispatcher flush agent as well so we can avoid content served from Dispatcher cache.   Feel free to reach out to us if you have any questions and don’t forget to tell your friends.   Thank you  ","categories": ["blog"],
        "tags": ["devops","aem","akamai","knowledge","sharing"],
        "url": "/blog/2021/04/25/creating-akamai-flush-agent",
        "teaser": null
      },{
        "title": "SPA, Headless, Widgets and AEM?",
        "excerpt":"There are many ways to build the web; most of the ways can be implemented in AEM, which one works best is going to depend on your authors. What the authors are willing to author, how involved do they get with content, and how involved do they want to get with crafting experiences? Once you answer, these questions the solution will pop out. The following should provide an overview of available options and arm you with information to make a choice.   SPA, Headless add Widgets patterns in AEM   Before we starte here is a context of each term   SPA - single page application an alternative to a multi-page website. SPA Editor - AEM native editor for SPA’s Headless - a pattern where you leverage API or GrapgQL to get data from server Widget - a component of a web page with clientside experience, it has basic HTML, and javascript turns into the interactive experience when loaded.   Now we can extrapolate these in relation to AEM. Here is a summary of patterns of implementing single-page and multi-page experience in AEM. In a lot of AEM implementations, you will find that all of these methods would have been utilised over time.   SPA - is a standalone application hosted externally to AEM, managed by developers, potential config by authors through content; can be headless. SPA in a Page - provides a method of host SPA application in a page, giving the ability to place SPA’s in different parts of the site; developer-focused, SPA has a dedicated component with possible authoring inputs; can be headless. SPA Editor - native ability to create SPA’s in AEM, allow full authoring of application; native components; can be headless. Page - a native way to create multi-page experiences, allow full authoring of pages, full content reuse and ability to use any components needed; a primary way of creating content for the web. Widgets in Page - small targeted components that are added to pages to create experiences; provides a way to create rich experiences that could be hard to author; can be headless.   Here is this information in a table.                                  Hosting               Page Experience               Focus               Content Usage                                               Pattern       Headless       External       Internal       Single Page       Multi-Page       Authoring       Developer       API       Page       Tags       Assets                 SPA       x       x               x                       x       x                                         SPA in Page       x       x               x                       x       x                                         SPA Editor       x               x       x               x               x       x       x       x                 Page                       x               x       x                       x       x       x                 Widget in Page       x       x       x       x       x       x               x       x       x       x           Adding a Design Language System into the mix would also add another level of complexity as SPA, and native Web will have different Design Language primarily because native AEM components can have Styles applied to them by authors, and SPA would have a more focused and controlled set of settings.   Conclusion   Focussing on AEM Authoring experience will always be beneficial as it will allow more people to help to grow experience. Having more eyes and hands helping to build the experience is always a good thing.   If you are must have a developer-centric experience and use AEM as a content repository, you can do it but you will be missing out on a lot of benefits that you would need to invent from sratch.   Using AEM SPA Editor will allow opening your experience building to authors so that they can help in any way they can. If you just have developers doing the authoring, then you will also missout on valuable input, and chances are you will rever to the vanila SPA pattern.   Going down the Widgets in a Page will give you the biggest impact as you can leverage all of the content authoring patterns and content services available in AEM. This will allow you to integrate widgets into existing pages, allow you to target them easily and importantly, all of this will be done by authors.   Obviously, all other patterns can be developed to the same level of maturity given appropriate time and effort.   Background   Here is the background information on building blocks that are used in SPA patterns.   Web Experiences   There are many ways to make great experiences for the web. In the end HTML and CSS is what all experiences are made of and its the details of how the developers choose to implement those experiences that varries. Traditional methods of we dev are either plain HTML pages or Single Page Application’s (SPA’s).   Plain HTML approach means that you develop multi-page experiences where a user is navigating a network of related pages. It’s a long term play, and you leverage a lot of technical and taxonomy tools to help you to play this out over a long period of time.      Single Page Applications or SPA’s is another approach that focuses all of the experiences into one page. This means that user does not navigate pages as such, they are confined to one page, and they navigate experience as its laid-out by the SPA, SPA uses traditional API’s or GraphQL to gather content it needs.      AEM native API’s   AEM technical strength is in the flexibility of content, content architecture and ability to render content in place in different ways. You can store content in AEM in anyway you want, structure it to make logical sense and retrieve it either with native API, GraphQL or custom API you need.   In AEM, you can store some content into a location /content/page then request its HTML representation /content/page.html, then request its XML representation /content/page.xml, then request its JSON representation /content/page.tidy.5.json, then request its Image representation /content/page.thumbnail.png and on and on.   AEM has a method for adding these renderers (html, json, xml, thubnail.png) that enable you to read content from anywhere and how you want it, essentially allowing the whole content repository to act as an API source, and you can read different bits of different content is many ways depending on your need.   AEM has a number of content experiences Content Fragments and Models, Experience Fragments, Tags and Sling API that allow you to get content from AEM. Additionally, ACS has several services that further complement OOTB functionality.   Aggregation API   When it comes to the traditional API approach, the aim it funnels all of the calls into one area, one “service” that handles a request for that content. You typically should have an API gateway to ensure you do not flood your backend service and you would have a number API returning either atomic data or aggregated set of data.      Aggregation of API’s is a pattern for gathering data from different API’s and presenting it in one package to the consumer. This pattern can be implemented both on the client and server-side. GraphQL essentially provides a server-side and client-side aggregation in one; you can get atomic data and aggregate as well with one API.      GraphQL API approach allows you to get the same data as traditional API but potentially at the client-side. This obviously has a lot of perceived flexibility as the structure of API is moved up the stack and managed by the UI layer, and the same methods should be used to protect the backend.   Headless AEM   Headless is a method of using AEM as a source of data, and the primary way of achieving this is by using API and GraphQL for getting data out of AEM. This pattern can be used in any SPA and Widget approach but does make AEM more developer-focused.      Widgets in AEM   Widgets are a way of creating AEM authoring components that have rich client-side presentations. This pattern allows full authoring experiences and all of the API patterns to be used.      Thank you   Please checkout the docker hub aemdesign/aem for latest AEM SDK images.   If you would like to contribute or fork the code, you can get it on GitHub https://github.com/aem-design and through Maven central.   Don’t forget to tell your friends.  ","categories": ["blog"],
        "tags": ["aem","spa","headless","widgets","knowledge","patterns"],
        "url": "/blog/2021/09/10/spa-headless-widgets-and-aem",
        "teaser": null
      }]
